<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Arena</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #dc2626;
            --secondary: #1e293b;
            --accent: #fbbf24;
            --dark: #0f172a;
            --light: #f8fafc;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --premium: #8b5cf6;
        }

        body {
            background: linear-gradient(135deg, var(--dark) 0%, var(--secondary) 100%);
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        /* Carátula de video */
        #video-intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .video-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
        }

        .video-loading-bar {
            width: 80%;
            max-width: 500px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 2rem;
        }

        .video-loading-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .video-skip-btn {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .video-skip-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Pantalla de carga */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-container {
            text-align: center;
            animation: fadeIn 1s ease;
        }

        .loading-logo {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, var(--primary), var(--danger));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 2rem;
            animation: pulse 2s infinite;
            border: 5px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 50px rgba(220, 38, 38, 0.5);
        }

        .loading-logo h1 {
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.5);
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem auto;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .loading-text {
            color: #94a3b8;
            margin-top: 1rem;
        }

        /* Menú principal */
        #main-menu, #game-screen, #editor-screen, #character-select {
            display: none;
            min-height: 100vh;
            padding: 2rem;
        }

        .screen-active {
            display: block !important;
            animation: slideUp 0.5s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }

        .header:hover .game-title {
            transform: scale(1.02);
        }

        .game-title {
            font-size: 4rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 1rem;
            background: linear-gradient(to right, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 30px rgba(220, 38, 38, 0.3);
            transition: transform 0.3s ease;
            display: inline-block;
            cursor: pointer;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 2rem;
        }

        .menu-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .menu-card {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .menu-card:hover {
            transform: translateY(-10px);
            border-color: var(--primary);
            box-shadow: 0 20px 40px rgba(220, 38, 38, 0.2);
        }

        .menu-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--primary), var(--danger));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            font-size: 2.5rem;
        }

        .menu-card h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .menu-card p {
            color: #94a3b8;
            line-height: 1.6;
        }

        /* CARRUSEL DE PERSONAJES - MEJORADO PARA CENTRAR */
        .character-carousel-container {
            position: relative;
            max-width: 900px;
            margin: 2rem auto 3rem;
            overflow: hidden;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 2rem;
        }

        .character-carousel {
            display: flex;
            transition: transform 0.5s ease;
            gap: 2rem;
        }

        .carousel-track {
            display: flex;
            width: 100%;
        }

        .character-carousel-item {
            min-width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            transition: all 0.3s ease;
            opacity: 0.6;
            transform: scale(0.9);
        }

        .character-carousel-item.active {
            transform: scale(1.05);
            opacity: 1;
        }

        .character-carousel-preview {
            width: 200px;
            height: 200px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
        }

        .character-carousel-item.active .character-carousel-preview {
            transform: scale(1.1);
            filter: drop-shadow(0 10px 25px rgba(251, 191, 36, 0.5));
        }

        .character-carousel-info {
            text-align: center;
            max-width: 500px;
        }

        .character-carousel-info h3 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }

        .character-carousel-description {
            color: #94a3b8;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .character-carousel-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 10px;
        }

        .carousel-stat {
            text-align: center;
        }

        .carousel-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .carousel-stat-label {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .carousel-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            justify-content: center;
        }

        .carousel-arrow {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        .carousel-arrow:hover {
            background: var(--primary);
            border-color: var(--primary);
            transform: translateY(-50%) scale(1.1);
        }

        .carousel-arrow.prev {
            left: 20px;
        }

        .carousel-arrow.next {
            right: 20px;
        }

        .carousel-indicators {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .carousel-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .carousel-indicator.active {
            background: var(--primary);
            transform: scale(1.2);
        }

        /* Selector de personajes anterior (mantener para compatibilidad) */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .character-card {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .character-card:hover, .character-card.selected {
            border-color: var(--accent);
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(251, 191, 36, 0.2);
        }

        .character-card.premium {
            border-color: var(--premium);
        }

        .character-card.premium:hover {
            border-color: var(--premium);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
        }

        .character-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }

        .character-card.available {
            opacity: 1;
            cursor: pointer;
            filter: none;
        }

        .premium-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--premium);
            color: white;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .price-tag {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(251, 191, 36, 0.2);
            color: var(--accent);
            font-size: 0.9rem;
            padding: 0.25rem 0.75rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .price-tag img {
            width: 16px;
            height: 16px;
        }

        .character-preview {
            width: 100px;
            height: 100px;
            margin: 0 auto 1rem;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .character-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }

        /* Botón de compra en personajes bloqueados */
        .buy-button {
            background: linear-gradient(135deg, var(--success), #10b981);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 0.5rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
        }

        .buy-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .buy-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Botón JUGAR principal */
        .play-button-container {
            text-align: center;
            margin: 2rem 0;
        }

        .play-button {
            background: linear-gradient(135deg, var(--primary), var(--danger));
            color: white;
            border: none;
            padding: 1rem 3rem;
            border-radius: 12px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.3);
        }

        .play-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(220, 38, 38, 0.4);
        }

        .play-button:active {
            transform: translateY(-2px);
        }

        /* Configuración de nivel */
        .level-config {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem auto;
            max-width: 500px;
        }

        .config-item {
            margin-bottom: 1.5rem;
        }

        .config-item label {
            display: block;
            margin-bottom: 0.5rem;
            color: #cbd5e1;
        }

        .config-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Controles */
        .controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            background: rgba(30, 41, 59, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:active {
            transform: scale(0.9);
            background: var(--primary);
        }

        .control-center {
            display: grid;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(3, 70px);
            gap: 10px;
        }

        /* HUD del juego - Pantalla completa */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            background: rgba(15, 23, 42, 0.9);
            padding: 0.75rem 2rem;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            height: 70px;
        }

        .hud-section {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hud-icon {
            font-size: 1.5rem;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hud-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .hud-label {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-right: 0.25rem;
        }

        /* Botones de acción en juego */
        .game-action-buttons {
            position: fixed;
            top: 85px;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
        }

        .game-action-btn {
            width: 50px;
            height: 50px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .game-action-btn:hover {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.3);
            transform: scale(1.1);
        }

        /* Botón de inventario */
        .inventory-btn {
            width: 50px;
            height: 50px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .inventory-btn img {
            width: 30px;
            height: 30px;
            object-fit: contain;
        }

        /* Ventana de inventario */
        .inventory-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid var(--accent);
            border-radius: 20px;
            padding: 2rem;
            z-index: 1000;
            backdrop-filter: blur(20px);
            display: none;
        }

        .inventory-modal.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .inventory-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 1rem;
        }

        .inventory-item {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .inventory-item:hover {
            transform: scale(1.05);
            border: 1px solid var(--accent);
        }

        .item-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 0.5rem;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .item-count {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .item-name {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        /* Tablero de juego - Pantalla completa */
        .game-board {
            display: grid;
            gap: 2px;
            margin: 70px auto 100px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            width: 100%;
            height: calc(100vh - 170px);
            overflow: auto;
            justify-content: center;
            align-content: center;
            touch-action: manipulation;
        }

        .game-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            position: relative;
            transition: all 0.2s ease;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .game-cell.touch-active {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--accent);
        }

        @media (max-width: 768px) {
            .game-cell {
                width: 30px;
                height: 30px;
            }
        }

        /* Colores de fondo para celdas sin imagen */
        .cell-empty { background-color: #1e293b; }
        .cell-wall { background-color: #92400e; }
        .cell-zombie { background-color: #7f1d1d; }
        .cell-rock { background-color: #475569; }
        .cell-box { background-color: #854d0e; }
        .cell-grass { background-color: #166534; }
        .cell-water { background-color: #1d4ed8; }
        .cell-rifle { background-color: #374151; }
        .cell-shotgun { background-color: #525252; }
        .cell-key { background-color: #ca8a04; }
        .cell-portal { background-color: #7c3aed; }
        .cell-start { background-color: #059669; }
        .cell-exit { background-color: #dc2626; }
        .cell-door { background-color: #7c2d12; }
        .cell-coin { background-color: #eab308; }
        .cell-bomb { background-color: #831843; }
        .cell-sword { background-color: #1e40af; }
        .cell-cactus { background-color: #166534; }
        .cell-bullet { background-color: #374151; }
        .cell-ammo { background-color: #525252; }
        .cell-rambo { background-color: #7c2d12; }

        .player-cell {
            position: relative;
            animation: pulse 1.5s infinite;
        }

        .zombie-cell {
            position: relative;
            animation: zombieMove 2s infinite alternate;
        }

        /* Proyectiles */
        .projectile {
            position: absolute;
            width: 8px;
            height: 8px;
            background: yellow;
            border-radius: 50%;
            z-index: 10;
        }

        /* Línea de disparo */
        .shooting-line {
            position: absolute;
            background: rgba(255, 255, 0, 0.5);
            height: 2px;
            transform-origin: left center;
            z-index: 5;
            pointer-events: none;
        }

        /* Selector de bomba */
        .bomb-selector {
            position: fixed;
            bottom: 150px;
            right: 2rem;
            background: rgba(30, 41, 59, 0.9);
            padding: 1rem;
            border-radius: 10px;
            display: none;
            z-index: 99;
            border: 2px solid var(--warning);
        }

        .bomb-selector.active {
            display: block;
        }

        .bomb-btn {
            background: var(--warning);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 0.5rem;
            display: block;
            width: 100%;
        }

        /* Editor - Configuración mejorada */
        .editor-config {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem auto;
            max-width: 600px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .editor-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        .tool-btn {
            padding: 1rem 1.5rem;
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 120px;
        }

        .tool-btn:hover, .tool-btn.active {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.2);
        }

        .tool-preview {
            width: 20px;
            height: 20px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Mensajes */
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            padding: 2rem 3rem;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            border: 2px solid var(--primary);
            box-shadow: 0 0 50px rgba(220, 38, 38, 0.5);
            animation: popIn 0.3s ease;
            min-width: 300px;
            display: none;
        }

        .message.active {
            display: block;
        }

        .message h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .message p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            color: #cbd5e1;
        }

        .message-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--primary), var(--danger));
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .message-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(220, 38, 38, 0.3);
        }

        /* Botones de acción en editor */
        .editor-action-buttons {
            position: fixed;
            top: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
            z-index: 100;
        }

        .editor-action-btn {
            padding: 0.8rem 1.5rem;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
        }

        .editor-action-btn:hover {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.3);
        }

        /* Niveles en editor - MODIFICADO PARA INCLUIR BOTONES DE EDITAR Y ELIMINAR */
        .levels-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .level-card {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .level-card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .level-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .level-btn {
            flex: 1;
            padding: 0.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .level-btn-edit {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .level-btn-edit:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .level-btn-play {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .level-btn-play:hover {
            background: rgba(34, 197, 94, 0.4);
        }

        .level-btn-delete {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .level-btn-delete:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        .level-btn:hover {
            transform: scale(1.05);
        }

        /* Estadísticas */
        .stats-container {
            display: flex;
            justify-content: space-around;
            margin: 2rem 0;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stat-box {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            min-width: 200px;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .stat-label-large {
            font-size: 1.1rem;
            color: #94a3b8;
        }

        /* Contador de agua */
        .water-counter {
            position: fixed;
            top: 85px;
            left: 2rem;
            background: rgba(30, 41, 59, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            display: none;
            z-index: 99;
            border: 2px solid #1d4ed8;
        }

        .water-counter.active {
            display: block;
        }

        /* Tabla de highscore - AHORA EN MENÚ PRINCIPAL */
        .highscore-container {
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem auto;
            max-width: 800px;
        }

        .highscore-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .highscore-table th {
            background: rgba(15, 23, 42, 0.8);
            padding: 1rem;
            text-align: left;
            color: var(--accent);
            border-bottom: 2px solid var(--primary);
        }

        .highscore-table td {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .highscore-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .highscore-rank {
            width: 60px;
            text-align: center;
            font-weight: bold;
        }

        .highscore-name {
            font-weight: bold;
        }

        .highscore-score {
            color: var(--accent);
            font-weight: bold;
            text-align: right;
        }

        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes zombieMove {
            0% { transform: translateX(-1px); }
            100% { transform: translateX(1px); }
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @keyframes slideUp {
            0% { transform: translateY(100px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes projectile {
            0% { transform: translate(0, 0); opacity: 1; }
            100% { transform: translate(var(--end-x), var(--end-y)); opacity: 0; }
        }

        /* Nuevas animaciones para controles táctiles */
        @keyframes swipeHint {
            0%, 100% { transform: translateX(0); opacity: 0.7; }
            50% { transform: translateX(20px); opacity: 1; }
        }

        @keyframes tapHint {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Utilidades */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        .text-center {
            text-align: center;
        }

        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        .mb-4 { margin-bottom: 2rem; }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--danger));
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        /* Bombas activas */
        .active-bomb {
            animation: bombPulse 1s infinite;
        }

        @keyframes bombPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }

        /* Pausa */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-content {
            background: rgba(15, 23, 42, 0.95);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid var(--primary);
        }

        /* Moneda en precio */
        .coin-price {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-weight: bold;
        }

        .coin-price img {
            width: 20px;
            height: 20px;
        }

        /* Monedas en menú principal */
        .coins-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #eab308;
            margin-bottom: 1rem;
        }

        .coins-display img {
            width: 32px;
            height: 32px;
        }

        /* Botones de pantalla completa */
        .fullscreen-buttons {
            position: fixed;
            top: 2rem;
            left: 2rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }

        .fullscreen-btn {
            padding: 0.5rem 1rem;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
        }

        .fullscreen-btn:hover {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.3);
        }

        /* Indicadores de control táctil */
        .touch-hint {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 41, 59, 0.9);
            padding: 1rem 1.5rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 1rem;
            z-index: 99;
            border: 2px solid var(--accent);
            backdrop-filter: blur(10px);
            animation: fadeIn 0.5s ease;
        }

        .touch-hint.hidden {
            display: none;
        }

        .hint-icon {
            font-size: 1.5rem;
            color: var(--accent);
            animation: swipeHint 2s infinite;
        }

        .hint-text {
            font-size: 0.9rem;
            color: #cbd5e1;
        }

        /* JOYSTICK MEJORADO - ESTILOS NUEVOS */
        .touch-joystick-area {
            position: fixed;
            bottom: 120px;
            left: 2rem;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 99;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .touch-joystick-area.active {
            display: block;
        }

        .touch-joystick-area::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        .joystick-center {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
            box-shadow: 0 0 15px rgba(220, 38, 38, 0.7);
            z-index: 2;
        }

        .joystick-center.active {
            background: var(--danger);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.9);
        }

        .joystick-directions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .joystick-direction {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(251, 191, 36, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-size: 0.8rem;
            opacity: 0.7;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .joystick-direction.up {
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .joystick-direction.down {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .joystick-direction.left {
            top: 50%;
            left: 15px;
            transform: translateY(-50%);
        }

        .joystick-direction.right {
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
        }

        .joystick-direction.diagonal {
            width: 25px;
            height: 25px;
            font-size: 0.7rem;
        }

        .joystick-direction.up-left {
            top: 25px;
            left: 25px;
        }

        .joystick-direction.up-right {
            top: 25px;
            right: 25px;
        }

        .joystick-direction.down-left {
            bottom: 25px;
            left: 25px;
        }

        .joystick-direction.down-right {
            bottom: 25px;
            right: 25px;
        }

        .joystick-direction.active {
            background: rgba(251, 191, 36, 0.5);
            opacity: 1;
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* Indicador de dirección del joystick */
        .joystick-direction-indicator {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-size: 0.8rem;
            color: var(--accent);
            border: 1px solid var(--accent);
            display: none;
            z-index: 100;
            white-space: nowrap;
        }

        .joystick-direction-indicator.active {
            display: block;
        }

        /* Botón de disparo táctil */
        .touch-shoot-btn {
            position: fixed;
            bottom: 120px;
            right: 2rem;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            display: none;
            backdrop-filter: blur(10px);
            animation: tapHint 1.5s infinite;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }

        .touch-shoot-btn.active {
            display: flex;
        }

        .touch-shoot-btn:active {
            transform: scale(0.9);
            background: rgba(220, 38, 38, 0.9);
        }

        /* Mejora para la línea de disparo */
        .aim-line {
            position: absolute;
            background: linear-gradient(to right, rgba(255, 255, 0, 0.8), rgba(255, 255, 0, 0.2));
            height: 3px;
            transform-origin: left center;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        /* Overlay de controles táctiles */
        .touch-controls-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 98;
            display: none;
            touch-action: manipulation;
        }

        .touch-controls-overlay.active {
            display: block;
        }

        /* Filtros para niveles */
        .level-filters {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.5rem 1.5rem;
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-btn.active {
            background: rgba(220, 38, 38, 0.3);
            border-color: var(--primary);
        }

        .filter-btn:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
        }

        .level-type-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 0.25rem 0.75rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .level-type-ai {
            background: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
            border: 1px solid #3b82f6;
        }

        .level-type-custom {
            background: rgba(139, 92, 246, 0.3);
            color: #8b5cf6;
            border: 1px solid #8b5cf6;
        }
    </style>
</head>
<body>
    <!-- Carátula de video -->
    <div id="video-intro">
        <div class="video-container">
            <video id="intro-video" preload="auto" playsinline muted>
                <source src="caratula.mp4" type="video/mp4">
                Tu navegador no soporta el video.
            </video>
            <div class="video-overlay">
                <h1 style="font-size: 4rem; color: white; text-shadow: 0 0 20px rgba(220, 38, 38, 0.8);">SANDBOX ARENA</h1>
                <p style="font-size: 1.5rem; color: #fbbf24;">Cargando experiencia...</p>
                <div class="video-loading-bar">
                    <div id="video-loading-progress" class="video-loading-progress"></div>
                </div>
                <button class="video-skip-btn" onclick="skipIntro()">
                    <i class="fas fa-forward"></i> Saltar
                </button>
            </div>
        </div>
    </div>

    <!-- Pantalla de carga -->
    <div id="loading-screen">
        <div class="loading-container">
            <div class="loading-logo">
                <h1>SA</h1>
            </div>
            <h2>SANDBOX ARENA</h2>
            <div class="loading-bar">
                <div id="loading-progress" class="loading-progress" style="width: 0%"></div>
            </div>
            <p id="loading-text" class="loading-text">Iniciando arena...</p>
        </div>
    </div>

    <!-- Menú principal -->
    <div id="main-menu" class="container">
        <div class="header">
            <h1 class="game-title" onclick="countTitleClicks()">SANDBOX ARENA</h1>
            <p class="subtitle">Elige tu personaje y sobrevive</p>
            <!-- Mostrar monedas obtenidas -->
            <div class="coins-display">
                <img src="moneda.png" alt="Monedas">
                <span id="total-coins-display">0</span>
            </div>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-number" id="highscore-coins">0</div>
                <div class="stat-label-large">Máximo de Monedas</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="total-levels">1</div>
                <div class="stat-label-large">Niveles Completados</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="total-zombies">0</div>
                <div class="stat-label-large">Zombies Eliminados</div>
            </div>
        </div>

        <!-- CARRUSEL DE PERSONAJES - MEJORADO -->
        <div class="character-carousel-container">
            <div class="carousel-arrow prev" onclick="previousCharacter()">
                <i class="fas fa-chevron-left"></i>
            </div>
            <div class="carousel-arrow next" onclick="nextCharacter()">
                <i class="fas fa-chevron-right"></i>
            </div>
            
            <div class="character-carousel" id="character-carousel">
                <!-- Los personajes se cargarán aquí dinámicamente -->
            </div>
            
            <div class="carousel-indicators" id="carousel-indicators">
                <!-- Los indicadores se generarán dinámicamente -->
            </div>
        </div>

        <div class="text-center mb-4">
            <p class="subtitle">Selecciona un personaje para comenzar la aventura</p>
            <p class="subtitle" style="color: var(--accent); font-size: 0.9rem; margin-top: 0.5rem;">
                ¡Los personajes premium se pueden comprar con monedas obtenidas en el juego!
            </p>
        </div>

        <!-- Botón JUGAR principal -->
        <div class="play-button-container">
            <button class="play-button" onclick="startGameFromMenu()">
                <i class="fas fa-play-circle"></i> JUGAR MODO JUGADOR
            </button>
        </div>

        <!-- Tabla de highscore - VISIBLE EN MENÚ PRINCIPAL -->
        <div class="highscore-container">
            <h2 class="text-center mb-2">🏆 Highscore Global</h2>
            <div id="highscore-loading" class="text-center">
                <p>Cargando puntajes...</p>
            </div>
            <table class="highscore-table" id="highscore-table">
                <thead>
                    <tr>
                        <th class="highscore-rank">#</th>
                        <th>Jugador</th>
                        <th>Personaje</th>
                        <th>Nivel</th>
                        <th class="highscore-score">Puntaje</th>
                        <th>Fecha</th>
                    </tr>
                </thead>
                <tbody id="highscore-body">
                    <!-- Los puntajes se cargarán aquí -->
                </tbody>
            </table>
        </div>

        <!-- Botón Modo Cerebro (oculto hasta hacer clic 7 veces en título) -->
        <div class="hidden" id="hidden-menu-options">
            <div class="menu-options">
                <div class="menu-card" onclick="showScreen('editor-screen')">
                    <div class="menu-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <h2>Modo Cerebro</h2>
                    <p>Diseña tus propios escenarios de supervivencia con bloques. Crea desafíos mortales.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Editor de niveles -->
    <div id="editor-screen">
        <div class="editor-action-buttons">
            <button class="editor-action-btn" onclick="saveLevel()">
                <i class="fas fa-save"></i> Guardar
            </button>
            <button class="editor-action-btn" onclick="createNewLevel()">
                <i class="fas fa-plus"></i> Nuevo
            </button>
            <button class="editor-action-btn" onclick="loadLevelsModal()">
                <i class="fas fa-list"></i> Niveles Guardados
            </button>
            <button class="editor-action-btn" onclick="showScreen('main-menu')">
                <i class="fas fa-home"></i> Menú
            </button>
        </div>

        <div class="container">
            <div class="header">
                <h1 class="game-title">MODO CEREBRO</h1>
                <p class="subtitle">Diseña tu propio nivel de supervivencia</p>
            </div>

            <div class="editor-config">
                <h3 class="text-center mb-2">Configuración del Nivel</h3>
                <div class="config-grid">
                    <div class="config-item">
                        <label class="setting-label">Tamaño del Tablero:</label>
                        <select id="editor-board-size" class="config-input" onchange="updateEditorSize()">
                            <option value="10">10x10</option>
                            <option value="12">12x12</option>
                            <option value="15">15x15</option>
                            <option value="20">20x20</option>
                        </select>
                    </div>
                    <div class="config-item">
                        <label class="setting-label">Tiempo (segundos):</label>
                        <input type="number" id="editor-time" class="config-input" value="120" min="30" max="600">
                    </div>
                </div>
                <div class="config-item">
                    <label class="setting-label">Número de Nivel:</label>
                    <input type="number" id="editor-level-number" class="config-input" value="1" min="1" max="100">
                </div>
                <div class="config-item">
                    <label class="setting-label">Nombre del Nivel:</label>
                    <input type="text" id="editor-level-name-input" class="config-input" value="Mi Nivel Personalizado">
                </div>
                <div class="text-center mt-2">
                    <p class="subtitle">Usa las herramientas para colocar la entrada (START) y salida (EXIT/Door)</p>
                </div>
            </div>

            <div class="editor-tools" id="editor-tools">
                <!-- Las herramientas se cargarán aquí -->
            </div>

            <div class="game-board" id="editor-board">
                <!-- El tablero del editor se generará aquí -->
            </div>
        </div>
    </div>

    <!-- Pantalla de juego -->
    <div id="game-screen">
        <!-- Overlay de pausa -->
        <div class="pause-overlay" id="pause-overlay">
            <div class="pause-content">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">JUEGO EN PAUSA</h2>
                <p style="margin-bottom: 2rem; color: #cbd5e1;">¿Qué quieres hacer?</p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn btn-primary" onclick="resumeGame()">
                        <i class="fas fa-play"></i> Continuar
                    </button>
                    <button class="btn btn-secondary" onclick="showScreen('main-menu')">
                        <i class="fas fa-home"></i> Menú Principal
                    </button>
                </div>
            </div>
        </div>

        <!-- Botones de pantalla completa -->
        <div class="fullscreen-buttons">
            <button class="fullscreen-btn" onclick="toggleFullscreen()" id="fullscreen-btn">
                <i class="fas fa-expand"></i> Pantalla Completa
            </button>
        </div>

        <!-- HUD superior -->
        <div class="hud">
            <div class="hud-section">
                <div class="hud-item">
                    <i class="fas fa-heart hud-icon" style="color: #ef4444;"></i>
                    <span class="hud-label">Vida:</span>
                    <span id="lives" class="hud-value">20</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-user hud-icon" style="color: #3b82f6;"></i>
                    <span id="character-name" class="hud-value">Civil</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-trophy hud-icon" style="color: #eab308;"></i>
                    <span class="hud-label">Nivel:</span>
                    <span id="current-level" class="hud-value">1</span>
                </div>
                <div class="hud-item">
                    <div class="coin-price">
                        <img src="moneda.png" alt="Monedas">
                        <span id="coins" class="hud-value">0</span>
                    </div>
                </div>
            </div>
            <div class="hud-section">
                <div class="hud-item">
                    <i class="fas fa-gun hud-icon" style="color: #94a3b8;"></i>
                    <span class="hud-label">Balas:</span>
                    <span id="shots" class="hud-value">0/0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-key hud-icon" style="color: #eab308;"></i>
                    <span class="hud-label">Llaves:</span>
                    <span id="keys" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-bomb hud-icon" style="color: #dc2626;"></i>
                    <span class="hud-label">Bombas:</span>
                    <span id="bombs" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-clock hud-icon" style="color: #f59e0b;"></i>
                    <span class="hud-label">Tiempo:</span>
                    <span id="time" class="hud-value">120</span>
                </div>
            </div>
        </div>

        <!-- Botones de acción en juego -->
        <div class="game-action-buttons">
            <button class="game-action-btn" onclick="togglePause()">
                <i class="fas fa-pause"></i>
            </button>
            <button class="game-action-btn" onclick="toggleInventory()">
                <i class="fas fa-backpack"></i>
            </button>
            <button class="game-action-btn" onclick="showScreen('main-menu')">
                <i class="fas fa-sign-out-alt"></i>
            </button>
        </div>

        <!-- Ventana de inventario -->
        <div class="inventory-modal" id="inventory-modal">
            <div class="inventory-header">
                <h2>Inventario</h2>
                <button class="btn btn-secondary" onclick="toggleInventory()">
                    <i class="fas fa-times"></i> Cerrar
                </button>
            </div>
            <div class="inventory-items" id="inventory-items">
                <!-- Los items del inventario se cargarán aquí -->
            </div>
        </div>

        <!-- Selector de bomba -->
        <div class="bomb-selector" id="bomb-selector">
            <p>Bomba lista para soltar</p>
            <button class="bomb-btn" onclick="placeBomb()">Soltar Bomba</button>
            <button class="bomb-btn" onclick="cancelBomb()" style="background: #6b7280;">Cancelar</button>
        </div>

        <!-- Contador de agua -->
        <div class="water-counter" id="water-counter">
            <i class="fas fa-water" style="color: #1d4ed8;"></i>
            <span id="water-steps">0/5</span>
        </div>

        <!-- JOYSTICK MEJORADO -->
        <div class="touch-joystick-area" id="touch-joystick-area">
            <div class="joystick-directions">
                <div class="joystick-direction up">↑</div>
                <div class="joystick-direction down">↓</div>
                <div class="joystick-direction left">←</div>
                <div class="joystick-direction right">→</div>
                <div class="joystick-direction diagonal up-left">↖</div>
                <div class="joystick-direction diagonal up-right">↗</div>
                <div class="joystick-direction diagonal down-left">↙</div>
                <div class="joystick-direction diagonal down-right">↘</div>
            </div>
            <div class="joystick-center" id="joystick-center"></div>
            <div class="joystick-direction-indicator" id="joystick-direction-indicator"></div>
        </div>

        <!-- Overlay para controles táctiles -->
        <div class="touch-controls-overlay" id="touch-controls-overlay"></div>

        <!-- Indicador de controles táctiles -->
        <div class="touch-hint" id="touch-hint">
            <div class="hint-icon">🕹️</div>
            <div class="hint-text">Usa el joystick para mover al personaje</div>
        </div>

        <!-- Botón de disparo táctil -->
        <div class="touch-shoot-btn" id="touch-shoot-btn">
            <i class="fas fa-burst"></i>
        </div>

        <!-- Tablero de juego -->
        <div class="game-board" id="game-board">
            <!-- El tablero de juego se generará aquí -->
        </div>

        <!-- Controles móviles -->
        <div class="controls">
            <div class="control-center">
                <div></div>
                <button class="control-btn" onclick="movePlayer(0, -1)">
                    <i class="fas fa-arrow-up"></i>
                </button>
                <div></div>
                <button class="control-btn" onclick="movePlayer(-1, 0)">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <button class="control-btn" onclick="attack()" style="background: var(--danger);">
                    <i class="fas fa-burst"></i>
                </button>
                <button class="control-btn" onclick="movePlayer(1, 0)">
                    <i class="fas fa-arrow-right"></i>
                </button>
                <div></div>
                <button class="control-btn" onclick="movePlayer(0, 1)">
                    <i class="fas fa-arrow-down"></i>
                </button>
                <div></div>
            </div>
        </div>
    </div>

    <!-- Mensajes y modales -->
    <div id="message-modal" class="message">
        <h2 id="message-title">¡Victoria!</h2>
        <p id="message-text">Has completado el nivel con éxito.</p>
        <button id="message-button" class="message-btn" onclick="hideMessage()">Continuar</button>
    </div>

    <!-- Modal de niveles (para editar/eliminar) -->
    <div id="levels-modal" class="message">
        <h2>Niveles Guardados</h2>
        
        <!-- Filtros para niveles -->
        <div class="level-filters">
            <button class="filter-btn active" onclick="filterLevels('all')">Todos</button>
            <button class="filter-btn" onclick="filterLevels('ai')">IA</button>
            <button class="filter-btn" onclick="filterLevels('custom')">Personalizados</button>
        </div>
        
        <div id="levels-list" class="levels-list">
            <!-- Los niveles se cargarán aquí -->
        </div>
        <div class="text-center mt-3">
            <button class="btn btn-secondary" onclick="hideMessage()">
                <i class="fas fa-times"></i> Cerrar
            </button>
        </div>
    </div>

    <script>
        // ============================
        // CONFIGURACIÓN DE FIREBASE
        // ============================
        const firebaseConfig = {
            apiKey: "AIzaSyDM9GK7_gnd0GaVbxwK9xnwl0qk75MnFXw",
            authDomain: "playmobil-2d74d.firebaseapp.com",
            projectId: "playmobil-2d74d",
            storageBucket: "playmobil-2d74d.firebasestorage.app",
            messagingSenderId: "85202851148",
            appId: "1:85202851148:web:bf8eba63238c06c7b4ebe9",
            measurementId: "G-MX2B76PCD6"
        };

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // ============================
        // CONFIGURACIÓN Y CONSTANTES
        // ============================
        const TILE_TYPES = {
            EMPTY: 'empty',
            WALL: 'wall',
            ZOMBIE: 'zombie',
            ZOMBIE_RAMBO: 'zombie_rambo',
            ROCK: 'rock',
            BOX: 'box',
            GRASS: 'grass',
            WATER: 'water',
            RIFLE: 'rifle',
            SHOTGUN: 'shotgun',
            KEY: 'key',
            PORTAL: 'portal',
            START: 'start',
            EXIT: 'exit',
            DOOR: 'door',
            COIN: 'coin',
            BOMB: 'bomb',
            SWORD: 'sword',
            CACTUS: 'cactus',
            BULLET: 'bullet',
            AMMO: 'ammo'
        };

        // Mapeo de tipos de tile a nombres de imagen
        const TILE_IMAGES = {
            [TILE_TYPES.WALL]: 'ladrillo.png',
            [TILE_TYPES.ROCK]: 'roca.png',
            [TILE_TYPES.GRASS]: 'pastizal.png',
            [TILE_TYPES.WATER]: 'agua.png',
            [TILE_TYPES.BOX]: 'caja.png',
            [TILE_TYPES.RIFLE]: 'rifle.png',
            [TILE_TYPES.SHOTGUN]: 'shotgun.png',
            [TILE_TYPES.KEY]: 'llave.png',
            [TILE_TYPES.PORTAL]: 'portal.png',
            [TILE_TYPES.START]: 'entradaocupada.png',
            [TILE_TYPES.EXIT]: 'exitclose.png',
            [TILE_TYPES.DOOR]: 'exitclose.png',
            [TILE_TYPES.COIN]: 'moneda.png',
            [TILE_TYPES.BOMB]: 'bomba.png',
            [TILE_TYPES.SWORD]: 'espada.png',
            [TILE_TYPES.ZOMBIE]: 'zombie.png',
            [TILE_TYPES.ZOMBIE_RAMBO]: 'zombirambo.png',
            [TILE_TYPES.CACTUS]: 'cactus.png',
            [TILE_TYPES.BULLET]: 'balas.png',
            [TILE_TYPES.AMMO]: 'municiones.png'
        };

        // Personajes disponibles con precios (incluyendo Pikachu)
        const CHARACTERS = [
            { 
                id: 'civil', 
                name: 'Civil', 
                image: 'civil.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 0,
                premium: false,
                health: 100, 
                speed: 1.0, 
                damage: 10, 
                description: 'Ciudadano común con instinto de supervivencia' 
            },
            { 
                id: 'pikachu', 
                name: 'Pikachu', 
                image: 'pikachu.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 150,
                premium: true,
                health: 120, 
                speed: 1.5, 
                damage: 30, 
                description: '¡Pika pika! Pokémon eléctrico con ataques rápidos y poderosos' 
            },
            { 
                id: 'batman', 
                name: 'Batman', 
                image: 'batman.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 150,
                premium: true,
                health: 200, 
                speed: 1.1, 
                damage: 40, 
                description: 'El caballero oscuro, maestro del combate y el sigilo' 
            },
            { 
                id: 'superman', 
                name: 'Superman', 
                image: 'superman.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 200,
                premium: true,
                health: 300, 
                speed: 1.3, 
                damage: 60, 
                description: 'El hombre de acero, invulnerable y superpoderoso' 
            },
            { 
                id: 'samurai', 
                name: 'Samurái', 
                image: 'samurai.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 20,
                premium: true,
                health: 120, 
                speed: 1.0, 
                damage: 30, 
                description: 'Guerrero letal con katana' 
            },
            { 
                id: 'ninja', 
                name: 'Ninja', 
                image: 'ninja.png',
                rifleImage: null,
                shotgunImage: 'ninjashotgun.png',
                swordImage: 'ninjaespada.png',
                price: 35,
                premium: true,
                health: 80, 
                speed: 1.2, 
                damage: 20, 
                description: 'Ágil y silencioso, maestro del sigilo' 
            },
            { 
                id: 'rambo', 
                name: 'Rambo', 
                image: 'rambo.png',
                rifleImage: 'ramborifle.png',
                shotgunImage: null,
                swordImage: null,
                price: 50,
                premium: true,
                health: 150, 
                speed: 0.9, 
                damage: 25, 
                description: 'Experto en combate y explosivos' 
            },
            { 
                id: 'terminator', 
                name: 'Terminator', 
                image: 'terminator.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 70,
                premium: true,
                health: 200, 
                speed: 0.8, 
                damage: 15, 
                description: 'Máquina imparable de combate' 
            },
            { 
                id: 'robot', 
                name: 'Robot', 
                image: 'robot.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 75,
                premium: true,
                health: 180, 
                speed: 0.9, 
                damage: 20, 
                description: 'Máquina de combate resistente a daños' 
            },
            { 
                id: 'hombrelobo', 
                name: 'Hombre Lobo', 
                image: 'hombrelobo.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 85,
                premium: true,
                health: 170, 
                speed: 1.1, 
                damage: 35, 
                description: 'Fuerza bestial bajo la luna llena' 
            },
            { 
                id: 'dracula', 
                name: 'Drácula', 
                image: 'dracula.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 80,
                premium: true,
                health: 160, 
                speed: 1.0, 
                damage: 30, 
                description: 'Vampiro inmortal con sed de sangre' 
            },
            { 
                id: 'goku', 
                name: 'Goku', 
                image: 'goku.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 100,
                premium: true,
                health: 250, 
                speed: 1.3, 
                damage: 50, 
                description: 'Guerrero Saiyajin con poder sobrehumano' 
            },
            { 
                id: 'mario', 
                name: 'Mario Bross', 
                image: 'mario.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 90,
                premium: true,
                health: 180, 
                speed: 1.2, 
                damage: 25, 
                description: 'Fontanero héroe del Reino Champiñón' 
            },
            { 
                id: 'spiderman', 
                name: 'Spiderman', 
                image: 'spiderman.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 5,
                premium: false,
                health: 110, 
                speed: 1.4, 
                damage: 20, 
                description: 'El trepamuros con reflejos de araña' 
            },
            { 
                id: 'scream', 
                name: 'Scream', 
                image: 'scream.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 5,
                premium: false,
                health: 95, 
                speed: 1.1, 
                damage: 35, 
                description: 'Asesino sigiloso con cuchillo' 
            },
            { 
                id: 'hulk', 
                name: 'Hulk', 
                image: 'hulk.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 120,
                premium: true,
                health: 300, 
                speed: 0.7, 
                damage: 60, 
                description: 'Gigante esmeralda con fuerza infinita' 
            },
            { 
                id: 'ironman', 
                name: 'Ironman', 
                image: 'ironman.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 110,
                premium: true,
                health: 200, 
                speed: 1.0, 
                damage: 40, 
                description: 'Genio, multimillonario, playboy, filántropo' 
            },
            { 
                id: 'tarzan', 
                name: 'Tarzán', 
                image: 'tarzan.png',
                rifleImage: null,
                shotgunImage: null,
                swordImage: null,
                price: 60,
                premium: true,
                health: 140, 
                speed: 1.5, 
                damage: 25, 
                description: 'Rey de la jungla con agilidad sobrehumana' 
            }
        ];

        // ============================
        // VARIABLES GLOBALES DEL JUEGO
        // ============================
        let currentScreen = 'video-intro';
        let selectedCharacter = null;
        let currentLevelIndex = 0;
        let currentLevel = null;
        let gameState = {
            grid: [],
            width: 10,
            height: 10,
            player: { x: 0, y: 0, image: '', angle: 0 },
            zombies: [],
            zombieRambos: [],
            lives: 20,
            time: 120,
            ammo: 0,
            keys: 0,
            coins: 0,
            bombs: 0,
            shots: 0,
            playing: false,
            paused: false,
            levelName: 'Nivel 1',
            character: null,
            inventory: {
                rifles: 0,
                shotguns: 0,
                swords: 0,
                keys: 0,
                coins: 0,
                bombs: 0,
                bullets: 0,
                ammo: 0
            },
            waterSteps: 0,
            hasBox: false,
            boxPosition: null,
            activeBombs: [],
            levelCompleted: false,
            startPosition: { x: 0, y: 0 },
            stats: {
                zombiesKilled: 0,
                coinsCollected: 0,
                levelsCompleted: 0
            },
            weaponType: null,
            maxShots: 0,
            // Variables para JOYSTICK MEJORADO
            isTouching: false,
            touchStartX: 0,
            touchStartY: 0,
            joystickActive: false,
            joystickDirection: null,
            joystickInterval: null,
            lastMoveTime: 0,
            moveDelay: 100,
            // Variables para movimiento fluido
            keysPressed: {},
            velocityX: 0,
            velocityY: 0,
            friction: 0.85,
            acceleration: 0.5,
            maxSpeed: 1.5,
            autoShoot: false,
            lastShotTime: 0,
            shootDelay: 300,
            // Variables para centrar carrusel
            carouselCenterIndex: 0
        };

        let editorState = {
            tool: TILE_TYPES.WALL,
            grid: [],
            width: 10,
            height: 10,
            name: 'Mi Nivel Personalizado',
            timeLimit: 120,
            levelNumber: 1,
            levelType: 'custom',
            editingExisting: false,
            editingLevelIndex: -1
        };

        let savedLevels = [];
        let gameStats = {
            highscoreCoins: 0,
            totalLevels: 0,
            totalZombies: 0,
            currentLevel: 1,
            playerCoins: 0,
            unlockedCharacters: ['civil', 'spiderman', 'scream'],
            playerName: 'Jugador' + Math.floor(Math.random() * 10000)
        };

        // Variables para carrusel de personajes
        let currentCarouselIndex = 0;
        let carouselItems = [];

        // Contador de clics en el título (oculto para el público)
        let titleClickCount = 0;
        let hiddenMenuVisible = false;

        // Highscore global
        let globalHighscores = [];

        // Control de pantalla completa
        let isFullscreen = false;

        // Detectar dispositivo táctil
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // ============================
        // INICIALIZACIÓN
        // ============================
        document.addEventListener('DOMContentLoaded', async () => {
            // Omitir la pantalla de video y mostrar directamente la pantalla de carga
            skipIntro();
        });

        function skipIntro() {
            const videoIntro = document.getElementById('video-intro');
            videoIntro.style.opacity = '0';
            setTimeout(() => {
                videoIntro.style.display = 'none';
                startLoadingScreen();
            }, 300);
        }

        function startLoadingScreen() {
            // Mostrar pantalla de carga
            document.getElementById('loading-screen').style.display = 'flex';
            
            // Cargar estadísticas
            loadStats();
            
            // Cargar niveles desde localStorage
            const saved = localStorage.getItem('sandboxLevels');
            if (saved) {
                savedLevels = JSON.parse(saved);
            }
            
            // Si no hay niveles, crear los 10 niveles por defecto
            if (savedLevels.length === 0) {
                createDefaultLevels();
            }

            // Inicializar editor
            initializeEditor();
            
            // Inicializar carrusel de personajes
            initializeCharacterCarousel();

            // Configurar controles de teclado
            setupKeyboardControls();

            // Configurar controles táctiles con JOYSTICK
            setupTouchControlsWithJoystick();

            // Cargar highscore global
            loadGlobalHighscores();

            // Configurar pantalla completa
            setupFullscreen();

            // Actualizar display de monedas
            updateCoinsDisplay();

            // Simular carga
            simulateLoading();
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                gameState.keysPressed[e.key.toLowerCase()] = true;
                
                // Disparo con espacio
                if (e.key === ' ' && gameState.playing && !gameState.paused) {
                    gameState.autoShoot = true;
                    shootFromPlayer();
                }
            });

            document.addEventListener('keyup', (e) => {
                gameState.keysPressed[e.key.toLowerCase()] = false;
                
                if (e.key === ' ') {
                    gameState.autoShoot = false;
                }
            });
        }

        function setupTouchControlsWithJoystick() {
            const gameBoard = document.getElementById('game-board');
            const touchOverlay = document.getElementById('touch-controls-overlay');
            const touchShootBtn = document.getElementById('touch-shoot-btn');
            const joystickArea = document.getElementById('touch-joystick-area');
            
            if (!gameBoard || !touchOverlay || !joystickArea) return;
            
            // Habilitar controles táctiles en dispositivos táctiles
            gameState.touchControlsEnabled = isTouchDevice;
            
            if (isTouchDevice) {
                // Mostrar controles táctiles y ocultar botones físicos
                const controls = document.querySelector('.controls');
                if (controls) {
                    controls.style.display = 'none';
                }
                
                // Mostrar joystick y botón de disparo táctil
                if (touchShootBtn) {
                    touchShootBtn.classList.add('active');
                }
                
                // Mostrar indicador de controles
                const touchHint = document.getElementById('touch-hint');
                if (touchHint) {
                    touchHint.classList.remove('hidden');
                    // Ocultar después de 5 segundos
                    setTimeout(() => {
                        touchHint.classList.add('hidden');
                    }, 5000);
                }
            }
            
            // Eventos táctiles para el joystick
            joystickArea.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystickArea.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystickArea.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickArea.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
            
            // Eventos de ratón para compatibilidad
            joystickArea.addEventListener('mousedown', handleJoystickMouseDown);
            joystickArea.addEventListener('mousemove', handleJoystickMouseMove);
            joystickArea.addEventListener('mouseup', handleJoystickMouseUp);
            joystickArea.addEventListener('mouseleave', handleJoystickMouseUp);
            
            // Configurar botón de disparo táctil
            if (touchShootBtn) {
                touchShootBtn.addEventListener('touchstart', handleShootTouchStart, { passive: false });
                touchShootBtn.addEventListener('touchend', handleShootTouchEnd, { passive: false });
                touchShootBtn.addEventListener('mousedown', handleShootMouseDown);
                touchShootBtn.addEventListener('mouseup', handleShootMouseUp);
            }
        }

        function handleJoystickStart(e) {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted) return;
            
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            
            gameState.isTouching = true;
            gameState.touchStartX = touch.clientX;
            gameState.touchStartY = touch.clientY;
            gameState.joystickActive = true;
            
            // Mostrar joystick
            const joystickArea = document.getElementById('touch-joystick-area');
            if (joystickArea) {
                joystickArea.classList.add('active');
            }
            
            // Activar overlay de controles táctiles
            const touchOverlay = document.getElementById('touch-controls-overlay');
            if (touchOverlay) {
                touchOverlay.classList.add('active');
            }
            
            // Posicionar joystick
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            
            updateJoystickPosition(dx, dy);
            updateJoystickDirection(dx, dy);
            
            // Iniciar movimiento continuo
            startContinuousMovement();
        }

        function handleJoystickMove(e) {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted || !gameState.joystickActive) return;
            
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            
            const joystickArea = document.getElementById('touch-joystick-area');
            if (!joystickArea) return;
            
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            
            updateJoystickPosition(dx, dy);
            updateJoystickDirection(dx, dy);
        }

        function handleJoystickEnd(e) {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted || !gameState.joystickActive) return;
            
            e.preventDefault();
            
            gameState.isTouching = false;
            gameState.joystickActive = false;
            gameState.joystickDirection = null;
            
            // Detener movimiento continuo
            stopContinuousMovement();
            
            // Ocultar joystick
            const joystickArea = document.getElementById('touch-joystick-area');
            if (joystickArea) {
                joystickArea.classList.remove('active');
            }
            
            // Resetear posición del centro del joystick
            const joystickCenter = document.getElementById('joystick-center');
            if (joystickCenter) {
                joystickCenter.style.transform = 'translate(-50%, -50%)';
                joystickCenter.classList.remove('active');
            }
            
            // Ocultar indicador de dirección
            const directionIndicator = document.getElementById('joystick-direction-indicator');
            if (directionIndicator) {
                directionIndicator.classList.remove('active');
            }
            
            // Desactivar overlay
            const touchOverlay = document.getElementById('touch-controls-overlay');
            if (touchOverlay) {
                touchOverlay.classList.remove('active');
            }
            
            // Desactivar todas las direcciones visuales
            const directions = document.querySelectorAll('.joystick-direction');
            directions.forEach(dir => dir.classList.remove('active'));
        }

        function handleJoystickMouseDown(e) {
            handleJoystickStart(e);
        }

        function handleJoystickMouseMove(e) {
            handleJoystickMove(e);
        }

        function handleJoystickMouseUp(e) {
            handleJoystickEnd(e);
        }

        function updateJoystickPosition(dx, dy) {
            const joystickCenter = document.getElementById('joystick-center');
            if (!joystickCenter) return;
            
            // Limitar movimiento a 50px del centro
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 50;
            
            let moveX = dx;
            let moveY = dy;
            
            if (distance > maxDistance) {
                moveX = (dx / distance) * maxDistance;
                moveY = (dy / distance) * maxDistance;
            }
            
            // Mover visual del joystick
            joystickCenter.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
            joystickCenter.classList.add('active');
        }

        function updateJoystickDirection(dx, dy) {
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 10) {
                gameState.joystickDirection = null;
                return;
            }
            
            // Calcular ángulo
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            // Determinar dirección
            let direction = '';
            let directionText = '';
            
            // Ángulos para las 8 direcciones
            if (angle >= -22.5 && angle < 22.5) {
                direction = 'right';
                directionText = '→ Derecha';
            } else if (angle >= 22.5 && angle < 67.5) {
                direction = 'down-right';
                directionText = '↘ Diagonal abajo-derecha';
            } else if (angle >= 67.5 && angle < 112.5) {
                direction = 'down';
                directionText = '↓ Abajo';
            } else if (angle >= 112.5 && angle < 157.5) {
                direction = 'down-left';
                directionText = '↙ Diagonal abajo-izquierda';
            } else if (angle >= 157.5 || angle < -157.5) {
                direction = 'left';
                directionText = '← Izquierda';
            } else if (angle >= -157.5 && angle < -112.5) {
                direction = 'up-left';
                directionText = '↖ Diagonal arriba-izquierda';
            } else if (angle >= -112.5 && angle < -67.5) {
                direction = 'up';
                directionText = '↑ Arriba';
            } else if (angle >= -67.5 && angle < -22.5) {
                direction = 'up-right';
                directionText = '↗ Diagonal arriba-derecha';
            }
            
            gameState.joystickDirection = direction;
            
            // Actualizar indicador visual
            updateDirectionIndicator(direction, directionText);
            
            // Actualizar direcciones activas visualmente
            updateActiveDirections(direction);
        }

        function updateDirectionIndicator(direction, text) {
            const indicator = document.getElementById('joystick-direction-indicator');
            if (!indicator) return;
            
            indicator.textContent = text;
            indicator.classList.add('active');
        }

        function updateActiveDirections(direction) {
            const directions = document.querySelectorAll('.joystick-direction');
            directions.forEach(dir => dir.classList.remove('active'));
            
            // Activar dirección principal
            const mainDirection = document.querySelector(`.joystick-direction.${direction}`);
            if (mainDirection) {
                mainDirection.classList.add('active');
            }
            
            // Activar direcciones relacionadas para mejor feedback visual
            if (direction.includes('-')) {
                const parts = direction.split('-');
                parts.forEach(part => {
                    const dir = document.querySelector(`.joystick-direction.${part}`);
                    if (dir) {
                        dir.classList.add('active');
                    }
                });
            }
        }

        function startContinuousMovement() {
            if (gameState.joystickInterval) {
                clearInterval(gameState.joystickInterval);
            }
            
            gameState.joystickInterval = setInterval(() => {
                if (!gameState.joystickActive || !gameState.joystickDirection || !gameState.playing || gameState.paused) {
                    return;
                }
                
                // Mover según la dirección actual
                const now = Date.now();
                if (now - gameState.lastMoveTime >= gameState.moveDelay) {
                    moveBasedOnJoystickDirection(gameState.joystickDirection);
                    gameState.lastMoveTime = now;
                }
            }, 50); // Revisar cada 50ms para movimiento suave
        }

        function stopContinuousMovement() {
            if (gameState.joystickInterval) {
                clearInterval(gameState.joystickInterval);
                gameState.joystickInterval = null;
            }
        }

        function moveBasedOnJoystickDirection(direction) {
            let dx = 0;
            let dy = 0;
            
            switch(direction) {
                case 'up':
                    dy = -1;
                    break;
                case 'down':
                    dy = 1;
                    break;
                case 'left':
                    dx = -1;
                    break;
                case 'right':
                    dx = 1;
                    break;
                case 'up-left':
                    dx = -1;
                    dy = -1;
                    break;
                case 'up-right':
                    dx = 1;
                    dy = -1;
                    break;
                case 'down-left':
                    dx = -1;
                    dy = 1;
                    break;
                case 'down-right':
                    dx = 1;
                    dy = 1;
                    break;
            }
            
            // Mover jugador
            movePlayer(dx, dy);
            
            // Actualizar ángulo del jugador según dirección
            if (dx !== 0 || dy !== 0) {
                gameState.player.angle = Math.atan2(dy, dx);
            }
        }

        function handleShootTouchStart(e) {
            e.preventDefault();
            if (!gameState.playing || gameState.paused || gameState.levelCompleted) return;
            
            // Iniciar disparo automático
            gameState.autoShoot = true;
            shootFromPlayer();
            
            // Añadir clase activa
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                btn.style.background = 'rgba(220, 38, 38, 0.9)';
            }
        }

        function handleShootTouchEnd(e) {
            e.preventDefault();
            gameState.autoShoot = false;
            
            // Remover clase activa
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = '';
                btn.style.background = '';
            }
        }

        function handleShootMouseDown(e) {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted) return;
            
            gameState.autoShoot = true;
            shootFromPlayer();
            
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                btn.style.background = 'rgba(220, 38, 38, 0.9)';
            }
        }

        function handleShootMouseUp(e) {
            gameState.autoShoot = false;
            
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = '';
                btn.style.background = '';
            }
        }

        function setupFullscreen() {
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function handleFullscreenChange() {
            isFullscreen = !!(document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement);
            
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            if (fullscreenBtn) {
                if (isFullscreen) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Salir Pantalla Completa';
                } else {
                    fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Pantalla Completa';
                }
            }
        }

        function toggleFullscreen() {
            const element = document.documentElement;
            
            if (!isFullscreen) {
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function simulateLoading() {
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                    
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('loading-screen').style.display = 'none';
                            showScreen('main-menu');
                        }, 500);
                    }, 500);
                }
                document.getElementById('loading-progress').style.width = progress + '%';
                document.getElementById('loading-text').textContent = 
                    progress < 30 ? 'Cargando recursos...' :
                    progress < 60 ? 'Inicializando arena...' :
                    progress < 90 ? 'Preparando personajes...' :
                    '¡Listo para la batalla!';
            }, 200);
        }

        function loadStats() {
            const savedStats = localStorage.getItem('sandboxStats');
            if (savedStats) {
                gameStats = JSON.parse(savedStats);
                // Asegurar que los nuevos personajes estén desbloqueados si ya estaban en stats anteriores
                const defaultUnlocked = ['civil', 'spiderman', 'scream'];
                defaultUnlocked.forEach(char => {
                    if (!gameStats.unlockedCharacters.includes(char)) {
                        gameStats.unlockedCharacters.push(char);
                    }
                });
            }
            updateStatsDisplay();
            updateCoinsDisplay();
        }

        function saveStats() {
            localStorage.setItem('sandboxStats', JSON.stringify(gameStats));
            updateStatsDisplay();
            updateCoinsDisplay();
        }

        function updateStatsDisplay() {
            document.getElementById('highscore-coins').textContent = gameStats.highscoreCoins;
            document.getElementById('total-levels').textContent = gameStats.totalLevels;
            document.getElementById('total-zombies').textContent = gameStats.totalZombies;
        }

        function updateCoinsDisplay() {
            const coinsDisplay = document.getElementById('total-coins-display');
            if (coinsDisplay) {
                coinsDisplay.textContent = gameStats.playerCoins;
            }
        }

        // ============================
        // CARRUSEL DE PERSONAJES MEJORADO (CENTRADO)
        // ============================
        function initializeCharacterCarousel() {
            const carouselContainer = document.getElementById('character-carousel');
            const indicatorsContainer = document.getElementById('carousel-indicators');
            
            if (!carouselContainer || !indicatorsContainer) return;
            
            carouselContainer.innerHTML = '';
            indicatorsContainer.innerHTML = '';
            carouselItems = [];
            
            CHARACTERS.forEach((character, index) => {
                // Verificar si el personaje está desbloqueado
                const isUnlocked = gameStats.unlockedCharacters.includes(character.id);
                const canAfford = gameStats.playerCoins >= character.price;
                
                // Crear elemento del carrusel
                const carouselItem = document.createElement('div');
                carouselItem.className = `character-carousel-item ${index === currentCarouselIndex ? 'active' : ''}`;
                carouselItem.dataset.index = index;
                carouselItem.dataset.characterId = character.id;
                
                // Determinar si el personaje está disponible para selección
                const isAvailable = isUnlocked || (!character.premium && canAfford);
                
                // Si es el primer personaje desbloqueado, seleccionarlo por defecto
                if (index === 0 && isUnlocked && !selectedCharacter) {
                    selectedCharacter = character;
                }
                
                // Verificar si este es el personaje seleccionado actualmente
                const isSelected = selectedCharacter && selectedCharacter.id === character.id && isAvailable;
                
                carouselItem.innerHTML = `
                    <div class="character-carousel-preview" style="background-image: url('${character.image}')"></div>
                    <div class="character-carousel-info">
                        <h3>${character.name} ${character.premium ? '👑' : ''}</h3>
                        <p class="character-carousel-description">${character.description}</p>
                        
                        <div class="character-carousel-stats">
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.health}</div>
                                <div class="carousel-stat-label">Salud</div>
                            </div>
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.speed}</div>
                                <div class="carousel-stat-label">Velocidad</div>
                            </div>
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.damage}</div>
                                <div class="carousel-stat-label">Daño</div>
                            </div>
                        </div>
                        
                        ${character.price > 0 ? `
                            <div class="coin-price" style="justify-content: center; margin-bottom: 1rem;">
                                <img src="moneda.png" alt="Monedas">
                                <span>${character.price} monedas</span>
                            </div>
                        ` : ''}
                        
                        <div class="carousel-buttons">
                            ${isUnlocked ? `
                                <button class="btn ${isSelected ? 'btn-primary' : 'btn-secondary'}" 
                                        onclick="selectCharacterFromCarousel(${index})"
                                        style="min-width: 150px;">
                                    ${isSelected ? '<i class="fas fa-check"></i> Seleccionado' : 'Seleccionar'}
                                </button>
                            ` : `
                                <button class="btn ${canAfford ? 'btn-primary' : 'btn-secondary'}" 
                                        onclick="buyCharacterFromCarousel(${index})"
                                        style="min-width: 150px;"
                                        ${!canAfford ? 'disabled' : ''}>
                                    <i class="fas fa-shopping-cart"></i> 
                                    ${canAfford ? `Comprar (${character.price})` : `Faltan ${character.price - gameStats.playerCoins}`}
                                </button>
                            `}
                        </div>
                        
                        ${!isUnlocked && character.premium ? `
                            <p style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.5rem;">
                                ${canAfford ? '' : `Necesitas ${character.price - gameStats.playerCoins} monedas más`}
                            </p>
                        ` : ''}
                    </div>
                `;
                
                carouselContainer.appendChild(carouselItem);
                carouselItems.push({
                    element: carouselItem,
                    character: character,
                    isUnlocked: isUnlocked,
                    isAvailable: isAvailable
                });
                
                // Crear indicador
                const indicator = document.createElement('div');
                indicator.className = `carousel-indicator ${index === currentCarouselIndex ? 'active' : ''}`;
                indicator.dataset.index = index;
                indicator.onclick = () => goToCharacter(index);
                indicatorsContainer.appendChild(indicator);
            });
            
            updateCarouselPosition();
            centerCarouselOnSelected();
        }

        function updateCarouselPosition() {
            const carousel = document.getElementById('character-carousel');
            if (!carousel) return;
            
            carousel.style.transform = `translateX(-${currentCarouselIndex * 100}%)`;
            
            // Actualizar clases activas
            carouselItems.forEach((item, index) => {
                if (item.element) {
                    if (index === currentCarouselIndex) {
                        item.element.classList.add('active');
                    } else {
                        item.element.classList.remove('active');
                    }
                }
            });
            
            // Actualizar indicadores
            const indicators = document.querySelectorAll('.carousel-indicator');
            indicators.forEach((indicator, index) => {
                if (index === currentCarouselIndex) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            });
        }

        function previousCharacter() {
            if (currentCarouselIndex > 0) {
                currentCarouselIndex--;
                updateCarouselPosition();
                centerCarouselOnSelected();
            }
        }

        function nextCharacter() {
            if (currentCarouselIndex < CHARACTERS.length - 1) {
                currentCarouselIndex++;
                updateCarouselPosition();
                centerCarouselOnSelected();
            }
        }

        function goToCharacter(index) {
            if (index >= 0 && index < CHARACTERS.length) {
                currentCarouselIndex = index;
                updateCarouselPosition();
                centerCarouselOnSelected();
            }
        }

        function centerCarouselOnSelected() {
            // Asegurar que el carrusel mantenga la posición correcta
            setTimeout(() => {
                updateCarouselPosition();
            }, 10);
        }

        function selectCharacterFromCarousel(index) {
            if (index < 0 || index >= carouselItems.length) return;
            
            const item = carouselItems[index];
            if (!item.isAvailable) return;
            
            // Deseleccionar todos
            carouselItems.forEach(item => {
                const button = item.element.querySelector('button');
                if (button) {
                    button.className = button.className.replace('btn-primary', 'btn-secondary');
                    button.innerHTML = button.innerHTML.replace('<i class="fas fa-check"></i> Seleccionado', 'Seleccionar');
                }
            });
            
            // Seleccionar este personaje
            selectedCharacter = item.character;
            
            // Actualizar botón del personaje seleccionado
            const button = item.element.querySelector('button');
            if (button) {
                button.className = button.className.replace('btn-secondary', 'btn-primary');
                button.innerHTML = '<i class="fas fa-check"></i> Seleccionado';
            }
            
            showMessage('Personaje Seleccionado', `Has seleccionado a ${item.character.name}`, 1000);
        }

        function buyCharacterFromCarousel(index) {
            if (index < 0 || index >= carouselItems.length) return;
            
            const item = carouselItems[index];
            if (!item.character.premium) return;
            
            // Usar la función existente de compra
            const success = buyCharacter(item.character);
            
            if (success) {
                // Recargar el carrusel para reflejar los cambios
                initializeCharacterCarousel();
                
                // Seleccionar automáticamente el personaje comprado
                selectCharacterFromCarousel(index);
            }
        }

        // ============================
        // SISTEMA DE COMPRA DE PERSONAJES PREMIUM
        // ============================
        function buyCharacter(character) {
            if (!character.premium) return true; // Personajes no premium son gratis
            
            // Verificar si ya está desbloqueado
            if (gameStats.unlockedCharacters.includes(character.id)) {
                return true;
            }
            
            // Verificar si tiene suficientes monedas
            if (gameStats.playerCoins >= character.price) {
                // Comprar personaje
                gameStats.playerCoins -= character.price;
                gameStats.unlockedCharacters.push(character.id);
                saveStats();
                
                showMessage('¡Personaje Comprado!', 
                    `¡Has comprado a ${character.name} por ${character.price} monedas!\nMonedas restantes: ${gameStats.playerCoins}`, 
                    3000);
                
                return true;
            } else {
                // No tiene suficientes monedas
                const needed = character.price - gameStats.playerCoins;
                showMessage('Monedas Insuficientes', 
                    `Necesitas ${needed} monedas más para comprar a ${character.name}.\nMonedas actuales: ${gameStats.playerCoins}`, 
                    3000);
                return false;
            }
        }

        // ============================
        // SISTEMA DE HIGHSCORE CON FIREBASE
        // ============================
        async function loadGlobalHighscores() {
            try {
                const snapshot = await db.collection('highscores')
                    .orderBy('score', 'desc')
                    .limit(20)
                    .get();
                
                globalHighscores = [];
                snapshot.forEach(doc => {
                    globalHighscores.push({ id: doc.id, ...doc.data() });
                });
                
                // Actualizar la tabla de highscore
                updateHighscoreTable();
                
                console.log('Highscores cargados:', globalHighscores.length);
            } catch (error) {
                console.error('Error cargando highscores:', error);
            }
        }

        function updateHighscoreTable() {
            const tableBody = document.getElementById('highscore-body');
            const loading = document.getElementById('highscore-loading');
            
            if (!tableBody || !loading) return;
            
            if (globalHighscores.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="text-center" style="color: #94a3b8;">
                            No hay puntajes registrados todavía
                        </td>
                    </tr>
                `;
                loading.style.display = 'none';
                return;
            }
            
            tableBody.innerHTML = '';
            
            globalHighscores.forEach((score, index) => {
                const date = score.date ? new Date(score.date.seconds * 1000).toLocaleDateString() : 'Hoy';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="highscore-rank">
                        ${index + 1}
                        ${index < 3 ? getMedalEmoji(index) : ''}
                    </td>
                    <td class="highscore-name">${score.playerName}</td>
                    <td>${score.character}</td>
                    <td>${score.level}</td>
                    <td class="highscore-score">${score.score.toLocaleString()}</td>
                    <td style="color: #94a3b8; font-size: 0.9rem;">${date}</td>
                `;
                
                // Destacar si es el jugador actual
                if (score.playerName === gameStats.playerName) {
                    row.style.backgroundColor = 'rgba(251, 191, 36, 0.1)';
                    row.style.borderLeft = '3px solid var(--accent)';
                }
                
                tableBody.appendChild(row);
            });
            
            loading.style.display = 'none';
        }

        function getMedalEmoji(rank) {
            switch(rank) {
                case 0: return '🥇';
                case 1: return '🥈';
                case 2: return '🥉';
                default: return '';
            }
        }

        async function saveHighscore(scoreData) {
            try {
                // Calcular puntaje total
                const totalScore = calculateTotalScore(scoreData);
                
                // Crear registro de highscore
                const highscore = {
                    playerName: gameStats.playerName,
                    character: selectedCharacter ? selectedCharacter.name : 'Desconocido',
                    level: currentLevelIndex + 1,
                    score: totalScore,
                    coins: scoreData.coins,
                    zombiesKilled: scoreData.zombiesKilled,
                    livesLeft: scoreData.lives,
                    timeLeft: scoreData.time,
                    date: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Guardar en Firebase
                await db.collection('highscores').add(highscore);
                
                console.log('Highscore guardado:', highscore);
                return true;
            } catch (error) {
                console.error('Error guardando highscore:', error);
                return false;
            }
        }

        function calculateTotalScore(scoreData) {
            let total = 0;
            
            // Puntos por monedas
            total += scoreData.coins * 10;
            
            // Puntos por zombies eliminados
            total += scoreData.zombiesKilled * 50;
            
            // Puntos por vidas restantes
            total += scoreData.lives * 20;
            
            // Puntos por tiempo restante
            total += scoreData.time * 5;
            
            // Bonus por completar nivel
            if (scoreData.won) {
                total += 1000;
            }
            
            // Multiplicador por nivel
            total *= (currentLevelIndex + 1);
            
            return total;
        }

        // ============================
        // MANEJO DE PANTALLAS
        // ============================
        function showScreen(screenName) {
            // Ocultar todas las pantallas
            const screens = ['loading-screen', 'main-menu', 'character-select', 'editor-screen', 'game-screen'];
            screens.forEach(screen => {
                const element = document.getElementById(screen);
                if (element) {
                    element.classList.remove('screen-active');
                    element.style.display = 'none';
                }
            });

            // Ocultar modales
            hideMessage();
            
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal) inventoryModal.classList.remove('active');
            
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) bombSelector.classList.remove('active');
            
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) pauseOverlay.classList.remove('active');

            currentScreen = screenName;

            // Mostrar la pantalla correspondiente
            const targetScreen = document.getElementById(screenName);
            if (targetScreen) {
                targetScreen.style.display = screenName === 'loading-screen' ? 'flex' : 'block';
                if (screenName !== 'loading-screen' && screenName !== 'video-intro') {
                    targetScreen.classList.add('screen-active');
                }
            }

            switch(screenName) {
                case 'main-menu':
                    updateStatsDisplay();
                    updateCoinsDisplay();
                    // Actualizar highscores si están cargados
                    if (globalHighscores.length > 0) {
                        updateHighscoreTable();
                    }
                    // Actualizar carrusel
                    initializeCharacterCarousel();
                    break;
                case 'editor-screen':
                    loadEditor();
                    break;
                case 'game-screen':
                    startGame();
                    break;
            }
        }

        // ============================
        // BOTÓN JUGAR PRINCIPAL - MODO JUGADOR
        // ============================
        function startGameFromMenu() {
            if (!selectedCharacter) {
                showMessage('Error', 'Debes seleccionar un personaje primero');
                return;
            }
            
            // Verificar si el personaje está desbloqueado
            if (selectedCharacter.premium && !gameStats.unlockedCharacters.includes(selectedCharacter.id)) {
                showMessage('Personaje Bloqueado', 
                    `¡${selectedCharacter.name} está bloqueado! Necesitas ${selectedCharacter.price} monedas para desbloquearlo.`,
                    3000);
                return;
            }
            
            // Siempre empezar desde el primer nivel
            currentLevelIndex = 0;
            currentLevel = savedLevels[currentLevelIndex];
            
            // Cargar progreso si existe, pero no permitir saltar niveles
            const savedProgress = localStorage.getItem('sandboxProgress');
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                // Solo usar el progreso si el jugador ha completado este nivel
                if (progress.currentLevel > currentLevelIndex + 1) {
                    currentLevelIndex = progress.currentLevel - 1;
                    if (currentLevelIndex >= savedLevels.length) {
                        currentLevelIndex = 0;
                    }
                    currentLevel = savedLevels[currentLevelIndex];
                }
            }
            
            showScreen('game-screen');
        }

        // ============================
        // EDITOR DE NIVELES - MEJORADO
        // ============================
        function initializeEditor() {
            // Cargar herramientas (incluyendo Zombie Rambo)
            const toolsContainer = document.getElementById('editor-tools');
            if (!toolsContainer) return;
            
            toolsContainer.innerHTML = '';

            Object.entries(TILE_TYPES).forEach(([key, type]) => {
                if (type === TILE_TYPES.EMPTY) return;
                
                const tool = document.createElement('div');
                tool.className = `tool-btn ${editorState.tool === type ? 'active' : ''}`;
                
                const imageName = TILE_IMAGES[type];
                const displayName = type === TILE_TYPES.ZOMBIE_RAMBO ? 'Zombie Rambo' : 
                                  type.charAt(0).toUpperCase() + type.slice(1).replace('_', ' ');
                
                tool.innerHTML = `
                    <div class="tool-preview" style="background-image: url('${imageName || ''}')"></div>
                    <span>${displayName}</span>
                `;
                
                tool.onclick = () => {
                    editorState.tool = type;
                    document.querySelectorAll('.tool-btn').forEach(t => t.classList.remove('active'));
                    tool.classList.add('active');
                };
                
                toolsContainer.appendChild(tool);
            });
        }

        function updateEditorSize() {
            const boardSize = document.getElementById('editor-board-size');
            if (!boardSize) return;
            
            const size = parseInt(boardSize.value);
            editorState.width = size;
            editorState.height = size;
            
            // Crear nuevo grid del tamaño correcto
            editorState.grid = Array(size * size).fill(TILE_TYPES.EMPTY);
            
            renderEditorGrid();
        }

        function loadEditor() {
            // Actualizar configuración desde inputs
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize && editorTime && levelNameInput && levelNumberInput) {
                editorState.width = parseInt(boardSize.value);
                editorState.height = parseInt(boardSize.value);
                editorState.timeLimit = parseInt(editorTime.value);
                editorState.name = levelNameInput.value;
                editorState.levelNumber = parseInt(levelNumberInput.value);
            }
            
            // Si no hay grid o el tamaño cambió, crear uno nuevo
            if (editorState.grid.length !== editorState.width * editorState.height) {
                editorState.grid = Array(editorState.width * editorState.height).fill(TILE_TYPES.EMPTY);
            }
            
            renderEditorGrid();
        }

        function renderEditorGrid() {
            const board = document.getElementById('editor-board');
            if (!board) return;
            
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${editorState.width}, 40px)`;

            for (let y = 0; y < editorState.height; y++) {
                for (let x = 0; x < editorState.width; x++) {
                    const index = y * editorState.width + x;
                    const tileType = editorState.grid[index] || TILE_TYPES.EMPTY;
                    const image = TILE_IMAGES[tileType];

                    const cell = document.createElement('div');
                    cell.className = `game-cell ${tileType === TILE_TYPES.EMPTY ? 'cell-empty' : ''}`;
                    
                    if (image && tileType !== TILE_TYPES.EMPTY) {
                        cell.style.backgroundImage = `url('${image}')`;
                    } else if (tileType === TILE_TYPES.ZOMBIE || tileType === TILE_TYPES.ZOMBIE_RAMBO) {
                        cell.style.backgroundColor = tileType === TILE_TYPES.ZOMBIE_RAMBO ? '#7c2d12' : '#7f1d1d';
                    }

                    cell.title = tileType;

                    cell.onclick = () => {
                        // Solo permitir una entrada y una salida
                        if (editorState.tool === TILE_TYPES.START) {
                            for (let i = 0; i < editorState.grid.length; i++) {
                                if (editorState.grid[i] === TILE_TYPES.START) {
                                    editorState.grid[i] = TILE_TYPES.EMPTY;
                                }
                            }
                        }
                        if (editorState.tool === TILE_TYPES.EXIT || editorState.tool === TILE_TYPES.DOOR) {
                            for (let i = 0; i < editorState.grid.length; i++) {
                                if (editorState.grid[i] === TILE_TYPES.EXIT || editorState.grid[i] === TILE_TYPES.DOOR) {
                                    editorState.grid[i] = TILE_TYPES.EMPTY;
                                }
                            }
                        }

                        editorState.grid[index] = editorState.tool;
                        renderEditorGrid();
                    };

                    board.appendChild(cell);
                }
            }
        }

        function createNewLevel() {
            editorState = {
                tool: TILE_TYPES.WALL,
                grid: Array(100).fill(TILE_TYPES.EMPTY),
                width: 10,
                height: 10,
                name: 'Mi Nivel Personalizado',
                timeLimit: 120,
                levelNumber: 1,
                levelType: 'custom',
                editingExisting: false,
                editingLevelIndex: -1
            };
            
            // Actualizar inputs
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize) boardSize.value = '10';
            if (editorTime) editorTime.value = '120';
            if (levelNameInput) levelNameInput.value = 'Mi Nivel Personalizado';
            if (levelNumberInput) levelNumberInput.value = '1';
            
            loadEditor();
        }

        function saveLevel() {
            const levelNameInput = document.getElementById('editor-level-name-input');
            const editorTime = document.getElementById('editor-time');
            const boardSize = document.getElementById('editor-board-size');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (!levelNameInput || !editorTime || !boardSize || !levelNumberInput) return;
            
            const name = levelNameInput.value || 'Mi Nivel Personalizado';
            const levelNumber = parseInt(levelNumberInput.value) || 1;
            
            editorState.name = name;
            editorState.timeLimit = parseInt(editorTime.value) || 120;
            editorState.width = parseInt(boardSize.value);
            editorState.height = parseInt(boardSize.value);
            editorState.levelNumber = levelNumber;
            editorState.levelType = 'custom';
            
            // Verificar que haya al menos una entrada y una salida
            const hasStart = editorState.grid.some(tile => tile === TILE_TYPES.START);
            const hasExit = editorState.grid.some(tile => tile === TILE_TYPES.EXIT || tile === TILE_TYPES.DOOR);
            
            if (!hasStart) {
                showMessage('Error', 'Debes colocar al menos una entrada (START) en el nivel');
                return;
            }
            
            if (!hasExit) {
                showMessage('Error', 'Debes colocar al menos una salida (EXIT o DOOR) en el nivel');
                return;
            }
            
            const newLevel = {
                name: editorState.name,
                width: editorState.width,
                height: editorState.height,
                timeLimit: editorState.timeLimit,
                levelNumber: editorState.levelNumber,
                levelType: editorState.levelType,
                grid: [...editorState.grid]
            };

            if (editorState.editingExisting && editorState.editingLevelIndex >= 0) {
                // Editar nivel existente
                savedLevels[editorState.editingLevelIndex] = newLevel;
                showMessage('¡Nivel Actualizado!', `El nivel "${name}" (Nivel ${levelNumber}) ha sido actualizado exitosamente.`);
            } else {
                // Crear nuevo nivel
                savedLevels.push(newLevel);
                showMessage('¡Nivel Guardado!', `El nivel "${name}" (Nivel ${levelNumber}) ha sido guardado exitosamente.`);
            }
            
            localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
            
            // Resetear estado de edición
            editorState.editingExisting = false;
            editorState.editingLevelIndex = -1;
        }

        // ============================
        // GESTIÓN DE NIVELES EN EDITOR (EDITAR/ELIMINAR)
        // ============================
        function loadLevelsModal() {
            const levelsList = document.getElementById('levels-list');
            if (!levelsList) return;
            
            levelsList.innerHTML = '';
            
            if (savedLevels.length === 0) {
                levelsList.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #94a3b8;">No hay niveles guardados</p>';
                document.getElementById('levels-modal').classList.add('active');
                return;
            }
            
            savedLevels.forEach((level, index) => {
                const levelCard = document.createElement('div');
                levelCard.className = 'level-card';
                
                // Contar elementos en el nivel
                const zombies = level.grid.filter(tile => tile === TILE_TYPES.ZOMBIE).length;
                const zombieRambos = level.grid.filter(tile => tile === TILE_TYPES.ZOMBIE_RAMBO).length;
                const coins = level.grid.filter(tile => tile === TILE_TYPES.COIN).length;
                const weapons = level.grid.filter(tile => 
                    tile === TILE_TYPES.RIFLE || tile === TILE_TYPES.SHOTGUN || tile === TILE_TYPES.SWORD
                ).length;
                
                levelCard.innerHTML = `
                    <div class="level-type-badge ${level.levelType === 'ai' ? 'level-type-ai' : 'level-type-custom'}">
                        ${level.levelType === 'ai' ? 'IA' : 'Personalizado'}
                    </div>
                    <h3>${level.name}</h3>
                    <p style="color: #94a3b8; margin: 0.5rem 0;">
                        Tamaño: ${level.width}x${level.height} | 
                        Tiempo: ${level.timeLimit}s | 
                        Nivel: ${level.levelNumber}
                    </p>
                    <p style="color: #94a3b8; font-size: 0.9rem;">
                        🧟 ${zombies} zombies | 🪖 ${zombieRambos} zombie Rambos | 🪙 ${coins} monedas | ⚔️ ${weapons} armas
                    </p>
                    <div class="level-actions">
                        <button class="level-btn level-btn-edit" onclick="editLevel(${index})">
                            <i class="fas fa-edit"></i> Editar
                        </button>
                        <button class="level-btn level-btn-play" onclick="playLevel(${index})">
                            <i class="fas fa-play"></i> Jugar
                        </button>
                        <button class="level-btn level-btn-delete" onclick="deleteLevel(${index})">
                            <i class="fas fa-trash"></i> Eliminar
                        </button>
                    </div>
                `;
                
                levelsList.appendChild(levelCard);
            });
            
            document.getElementById('levels-modal').classList.add('active');
        }

        function filterLevels(filter) {
            const filterBtns = document.querySelectorAll('.filter-btn');
            filterBtns.forEach(btn => btn.classList.remove('active'));
            
            const activeBtn = Array.from(filterBtns).find(btn => 
                btn.textContent.toLowerCase().includes(filter)
            );
            if (activeBtn) activeBtn.classList.add('active');
            
            loadLevelsModal(); // Recargar con filtro aplicado
        }

        function editLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            const level = savedLevels[index];
            
            // Cargar nivel en el editor
            editorState = {
                tool: TILE_TYPES.WALL,
                grid: [...level.grid],
                width: level.width,
                height: level.height,
                name: level.name,
                timeLimit: level.timeLimit,
                levelNumber: level.levelNumber,
                levelType: level.levelType,
                editingExisting: true,
                editingLevelIndex: index
            };
            
            // Actualizar inputs
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize) boardSize.value = level.width.toString();
            if (editorTime) editorTime.value = level.timeLimit.toString();
            if (levelNameInput) levelNameInput.value = level.name;
            if (levelNumberInput) levelNumberInput.value = level.levelNumber.toString();
            
            // Cerrar modal y cargar editor
            hideMessage();
            loadEditor();
            
            showMessage('Editando Nivel', `Estás editando: ${level.name}`, 2000);
        }

        function playLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            // Cargar nivel
            currentLevelIndex = index;
            currentLevel = savedLevels[index];
            
            // Cerrar modal y empezar juego
            hideMessage();
            showScreen('game-screen');
        }

        function deleteLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            const levelName = savedLevels[index].name;
            
            if (confirm(`¿Estás seguro de que quieres eliminar el nivel "${levelName}"?`)) {
                savedLevels.splice(index, 1);
                localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
                
                // Si estábamos editando este nivel, resetear editor
                if (editorState.editingExisting && editorState.editingLevelIndex === index) {
                    createNewLevel();
                }
                
                showMessage('Nivel Eliminado', `El nivel "${levelName}" ha sido eliminado.`, 2000);
                
                // Recargar la lista
                setTimeout(loadLevelsModal, 1000);
            }
        }

        // ============================
        // JUEGO PRINCIPAL (CON MOVIMIENTO MEJORADO Y JOYSTICK)
        // ============================
        function startGame() {
            if (!currentLevel) {
                currentLevel = savedLevels[currentLevelIndex];
            }

            // Reiniciar estado del juego
            gameState = {
                grid: [...currentLevel.grid],
                width: currentLevel.width,
                height: currentLevel.height,
                player: findStartPosition(),
                zombies: findZombies(),
                zombieRambos: findZombieRambos(),
                lives: 20,
                time: currentLevel.timeLimit,
                ammo: 0,
                keys: 0,
                coins: 0,
                bombs: 0,
                shots: 0,
                playing: true,
                paused: false,
                levelName: currentLevel.name,
                character: selectedCharacter,
                inventory: {
                    rifles: 0,
                    shotguns: 0,
                    swords: 0,
                    keys: 0,
                    coins: 0,
                    bombs: 0,
                    bullets: 0,
                    ammo: 0
                },
                waterSteps: 0,
                hasBox: false,
                boxPosition: null,
                activeBombs: [],
                levelCompleted: false,
                startPosition: findStartPosition(),
                stats: {
                    zombiesKilled: 0,
                    coinsCollected: 0,
                    levelsCompleted: 0
                },
                weaponType: null,
                maxShots: 0,
                // Variables para JOYSTICK MEJORADO
                isTouching: false,
                touchStartX: 0,
                touchStartY: 0,
                joystickActive: false,
                joystickDirection: null,
                joystickInterval: null,
                lastMoveTime: 0,
                moveDelay: 100,
                // Variables para movimiento fluido
                keysPressed: {},
                velocityX: 0,
                velocityY: 0,
                friction: 0.85,
                acceleration: 0.5,
                maxSpeed: selectedCharacter ? selectedCharacter.speed * 0.5 : 1.0,
                autoShoot: false,
                lastShotTime: 0,
                shootDelay: 300
            };

            // Actualizar HUD
            updateHUD();
            renderGameGrid();

            // Mostrar nivel actual
            const currentLevelEl = document.getElementById('current-level');
            const characterNameEl = document.getElementById('character-name');
            
            if (currentLevelEl) currentLevelEl.textContent = currentLevel.levelNumber || gameStats.currentLevel;
            if (characterNameEl) characterNameEl.textContent = selectedCharacter.name;

            // Configurar controles según el dispositivo
            if (isTouchDevice) {
                // Mostrar controles táctiles con joystick
                const touchShootBtn = document.getElementById('touch-shoot-btn');
                if (touchShootBtn) {
                    touchShootBtn.classList.add('active');
                }
                
                // Ocultar controles físicos
                const controls = document.querySelector('.controls');
                if (controls) {
                    controls.style.display = 'none';
                }
            } else {
                // Mostrar controles físicos
                const controls = document.querySelector('.controls');
                if (controls) {
                    controls.style.display = 'flex';
                }
                
                // Ocultar controles táctiles
                const touchShootBtn = document.getElementById('touch-shoot-btn');
                if (touchShootBtn) {
                    touchShootBtn.classList.remove('active');
                }
            }

            // Iniciar temporizador
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(gameLoop, 1000);

            // Iniciar movimiento de zombies
            if (gameState.zombieTimer) clearInterval(gameState.zombieTimer);
            gameState.zombieTimer = setInterval(moveZombies, 3000);

            // Iniciar movimiento de zombies Rambo (más rápido)
            if (gameState.ramboTimer) clearInterval(gameState.ramboTimer);
            gameState.ramboTimer = setInterval(moveZombieRambos, 1500);

            // Iniciar temporizador de bombas
            if (gameState.bombTimer) clearInterval(gameState.bombTimer);
            gameState.bombTimer = setInterval(checkBombs, 1000);
            
            // Iniciar temporizador de gravedad para cajas
            if (gameState.boxGravityTimer) clearInterval(gameState.boxGravityTimer);
            gameState.boxGravityTimer = setInterval(checkBoxGravity, 500);
            
            // Iniciar loop de animación para movimiento fluido
            if (gameState.animationFrame) cancelAnimationFrame(gameState.animationFrame);
            gameState.animationFrame = requestAnimationFrame(updatePlayerMovement);
        }

        function updatePlayerMovement() {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted) {
                gameState.animationFrame = requestAnimationFrame(updatePlayerMovement);
                return;
            }

            // MOVIMIENTO FLUIDO CON TECLADO
            // Aplicar aceleración basada en teclas presionadas
            if (gameState.keysPressed['w'] || gameState.keysPressed['arrowup']) {
                gameState.velocityY -= gameState.acceleration;
                gameState.player.angle = -Math.PI / 2; // Mirar hacia arriba
            }
            if (gameState.keysPressed['s'] || gameState.keysPressed['arrowdown']) {
                gameState.velocityY += gameState.acceleration;
                gameState.player.angle = Math.PI / 2; // Mirar hacia abajo
            }
            if (gameState.keysPressed['a'] || gameState.keysPressed['arrowleft']) {
                gameState.velocityX -= gameState.acceleration;
                gameState.player.angle = Math.PI; // Mirar hacia la izquierda
            }
            if (gameState.keysPressed['d'] || gameState.keysPressed['arrowright']) {
                gameState.velocityX += gameState.acceleration;
                gameState.player.angle = 0; // Mirar hacia la derecha
            }

            // Aplicar fricción
            gameState.velocityX *= gameState.friction;
            gameState.velocityY *= gameState.friction;

            // Limitar velocidad máxima
            const speed = Math.sqrt(gameState.velocityX * gameState.velocityX + gameState.velocityY * gameState.velocityY);
            if (speed > gameState.maxSpeed) {
                gameState.velocityX = (gameState.velocityX / speed) * gameState.maxSpeed;
                gameState.velocityY = (gameState.velocityY / speed) * gameState.maxSpeed;
            }

            // Si hay velocidad, mover al jugador
            if (Math.abs(gameState.velocityX) > 0.01 || Math.abs(gameState.velocityY) > 0.01) {
                const newX = gameState.player.x + gameState.velocityX;
                const newY = gameState.player.y + gameState.velocityY;
                
                // Verificar colisiones
                if (canMoveTo(newX, newY)) {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    
                    // Recolectar items en la nueva posición
                    const index = Math.floor(newY) * gameState.width + Math.floor(newX);
                    const tile = gameState.grid[index];
                    collectItem(index, tile);
                    
                    renderGameGrid();
                } else {
                    // Rebote en paredes
                    gameState.velocityX *= -0.5;
                    gameState.velocityY *= -0.5;
                }
            }

            // Disparo automático
            if (gameState.autoShoot && gameState.weaponType) {
                const now = Date.now();
                if (now - gameState.lastShotTime > gameState.shootDelay) {
                    shootFromPlayer();
                    gameState.lastShotTime = now;
                }
            }

            // Verificar colisión con zombies
            checkZombieCollision();

            gameState.animationFrame = requestAnimationFrame(updatePlayerMovement);
        }

        function canMoveTo(x, y) {
            const floorX = Math.floor(x);
            const floorY = Math.floor(y);
            
            // Verificar límites
            if (floorX < 0 || floorX >= gameState.width || floorY < 0 || floorY >= gameState.height) {
                return false;
            }
            
            const index = floorY * gameState.width + floorX;
            const tile = gameState.grid[index];
            
            // Verificar si es transitable
            if ([TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX, TILE_TYPES.CACTUS].includes(tile)) {
                return false;
            }
            
            return true;
        }

        function findStartPosition() {
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.START) {
                    return {
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        image: selectedCharacter.image,
                        angle: 0
                    };
                }
            }
            // Si no hay entrada, usar la primera celda
            return { x: 0, y: 0, image: selectedCharacter.image, angle: 0 };
        }

        function findZombies() {
            const zombies = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.ZOMBIE) {
                    zombies.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        id: zombies.length,
                        image: 'zombie.png',
                        lastMoveDirection: null,
                        type: 'normal'
                    });
                }
            }
            return zombies;
        }

        function findZombieRambos() {
            const zombieRambos = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.ZOMBIE_RAMBO) {
                    zombieRambos.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        id: zombieRambos.length,
                        image: 'zombirambo.png',
                        lastMoveDirection: null,
                        type: 'rambo',
                        lastShotTime: 0,
                        shootDelay: 2000,
                        range: 5
                    });
                }
            }
            return zombieRambos;
        }

        function renderGameGrid() {
            const board = document.getElementById('game-board');
            if (!board) return;
            
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${gameState.width}, 40px)`;

            for (let y = 0; y < gameState.height; y++) {
                for (let x = 0; x < gameState.width; x++) {
                    const index = y * gameState.width + x;
                    const tileType = gameState.grid[index];
                    const image = TILE_IMAGES[tileType];

                    const cell = document.createElement('div');
                    cell.className = `game-cell ${tileType === TILE_TYPES.EMPTY ? 'cell-empty' : ''}`;
                    
                    // Verificar si hay una bomba activa en esta celda
                    const hasBomb = gameState.activeBombs.some(bomb => bomb.x === x && bomb.y === y);
                    
                    if (hasBomb) {
                        cell.classList.add('active-bomb');
                        cell.style.backgroundImage = `url('bomba.png')`;
                    } else if (image && tileType !== TILE_TYPES.EMPTY && tileType !== TILE_TYPES.ZOMBIE && tileType !== TILE_TYPES.ZOMBIE_RAMBO) {
                        cell.style.backgroundImage = `url('${image}')`;
                    }

                    // Mostrar jugador (con rotación)
                    const playerX = Math.floor(gameState.player.x);
                    const playerY = Math.floor(gameState.player.y);
                    if (playerX === x && playerY === y) {
                        cell.classList.add('player-cell');
                        cell.style.backgroundImage = `url('${gameState.player.image}')`;
                        // Aplicar rotación
                        cell.style.transform = `rotate(${gameState.player.angle}rad)`;
                    }

                    // Mostrar zombies normales
                    const zombieHere = gameState.zombies.find(z => Math.floor(z.x) === x && Math.floor(z.y) === y);
                    if (zombieHere) {
                        cell.classList.add('zombie-cell');
                        cell.style.backgroundImage = `url('${zombieHere.image}')`;
                    }

                    // Mostrar zombies Rambo
                    const ramboHere = gameState.zombieRambos.find(z => Math.floor(z.x) === x && Math.floor(z.y) === y);
                    if (ramboHere) {
                        cell.classList.add('zombie-cell');
                        cell.style.backgroundImage = `url('${ramboHere.image}')`;
                    }

                    // Mostrar caja sostenida
                    if (gameState.hasBox && gameState.boxPosition && gameState.boxPosition.x === x && gameState.boxPosition.y === y) {
                        cell.style.backgroundImage = `url('caja.png')`;
                        cell.style.opacity = '0.8';
                    }

                    board.appendChild(cell);
                }
            }
        }

        function updateHUD() {
            const elements = {
                'lives': document.getElementById('lives'),
                'time': document.getElementById('time'),
                'character-name': document.getElementById('character-name'),
                'keys': document.getElementById('keys'),
                'coins': document.getElementById('coins'),
                'bombs': document.getElementById('bombs'),
                'shots': document.getElementById('shots')
            };

            if (elements.lives) elements.lives.textContent = gameState.lives;
            if (elements.time) elements.time.textContent = gameState.time;
            if (elements['character-name']) elements['character-name'].textContent = selectedCharacter.name;
            if (elements.keys) elements.keys.textContent = gameState.keys;
            if (elements.coins) elements.coins.textContent = gameState.coins;
            if (elements.bombs) elements.bombs.textContent = gameState.bombs;
            if (elements.shots) elements.shots.textContent = `${gameState.shots}/${gameState.maxShots}`;
        }

        function togglePause() {
            if (!gameState.playing) return;
            
            gameState.paused = !gameState.paused;
            const pauseOverlay = document.getElementById('pause-overlay');
            
            if (pauseOverlay) {
                if (gameState.paused) {
                    pauseOverlay.classList.add('active');
                } else {
                    pauseOverlay.classList.remove('active');
                }
            }
        }

        function resumeGame() {
            gameState.paused = false;
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) {
                pauseOverlay.classList.remove('active');
            }
        }

        function gameLoop() {
            if (!gameState.playing || gameState.paused) return;

            // Actualizar tiempo
            gameState.time--;
            const timeEl = document.getElementById('time');
            if (timeEl) timeEl.textContent = gameState.time;

            // Verificar fin del tiempo
            if (gameState.time <= 0) {
                endGame(false, '¡Se acabó el tiempo!');
                return;
            }

            // Verificar si el jugador está en la salida
            const playerX = Math.floor(gameState.player.x);
            const playerY = Math.floor(gameState.player.y);
            const playerIndex = playerY * gameState.width + playerX;
            const tileAtPlayer = gameState.grid[playerIndex];
            
            if (tileAtPlayer === TILE_TYPES.EXIT || tileAtPlayer === TILE_TYPES.DOOR) {
                // Verificar si necesita llave
                const hasDoor = gameState.grid.some(t => t === TILE_TYPES.DOOR);
                if (!hasDoor || gameState.keys > 0) {
                    gameState.levelCompleted = true;
                    endGame(true, '¡Has completado el nivel!');
                }
            }

            // Actualizar contador de agua si está activo
            if (gameState.waterSteps > 0) {
                gameState.waterSteps--;
                const waterStepsEl = document.getElementById('water-steps');
                const waterCounter = document.getElementById('water-counter');
                
                if (waterStepsEl) waterStepsEl.textContent = `${gameState.waterSteps}/5`;
                if (waterCounter) {
                    if (gameState.waterSteps <= 0) {
                        waterCounter.classList.remove('active');
                    }
                }
            }
        }

        function moveZombies() {
            if (!gameState.playing || gameState.paused) return;

            gameState.zombies.forEach(zombie => {
                // LOS ZOMBIS NO PUEDEN VER AL JUGADOR EN LA ENTRADA
                // Verificar si el jugador está en la entrada
                const playerInStart = gameState.grid[Math.floor(gameState.player.y) * gameState.width + Math.floor(gameState.player.x)] === TILE_TYPES.START;
                
                if (playerInStart) {
                    // Si el jugador está en la entrada, los zombies no se mueven hacia él
                    return;
                }
                
                // Movimiento hacia el jugador
                const dx = Math.sign(gameState.player.x - zombie.x);
                const dy = Math.sign(gameState.player.y - zombie.y);

                let newX = zombie.x;
                let newY = zombie.y;

                // Priorizar movimiento horizontal o vertical aleatoriamente
                if (Math.random() > 0.5 && dx !== 0) {
                    newX += dx * 0.5;
                } else if (dy !== 0) {
                    newY += dy * 0.5;
                }

                // Verificar colisiones
                const floorX = Math.floor(newX);
                const floorY = Math.floor(newY);
                
                if (floorX >= 0 && floorX < gameState.width && floorY >= 0 && floorY < gameState.height) {
                    const newIndex = floorY * gameState.width + floorX;
                    const tile = gameState.grid[newIndex];
                    
                    // Zombies no pueden pasar por obstáculos
                    if (![TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX, TILE_TYPES.WATER, 
                         TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START, TILE_TYPES.CACTUS].includes(tile)) {
                        
                        // Verificar si hay otro zombie en esa posición
                        const zombieAtPos = gameState.zombies.find(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                        const ramboAtPos = gameState.zombieRambos.find(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                        
                        if (!zombieAtPos && !ramboAtPos) {
                            zombie.x = newX;
                            zombie.y = newY;
                        }
                    }
                }

                // Verificar colisión con jugador
                if (Math.floor(zombie.x) === Math.floor(gameState.player.x) && Math.floor(zombie.y) === Math.floor(gameState.player.y)) {
                    handlePlayerHit();
                }
            });
        }

        function moveZombieRambos() {
            if (!gameState.playing || gameState.paused) return;

            gameState.zombieRambos.forEach(rambo => {
                // Calcular distancia al jugador
                const dx = gameState.player.x - rambo.x;
                const dy = gameState.player.y - rambo.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Si el jugador está dentro del rango, disparar
                if (distance <= rambo.range) {
                    const now = Date.now();
                    if (now - rambo.lastShotTime > rambo.shootDelay) {
                        // Disparar hacia el jugador
                        shootFromZombieRambo(rambo, dx / distance, dy / distance);
                        rambo.lastShotTime = now;
                    }
                    
                    // Moverse hacia el jugador
                    const moveX = Math.sign(dx) * 0.3;
                    const moveY = Math.sign(dy) * 0.3;
                    
                    let newX = rambo.x + moveX;
                    let newY = rambo.y + moveY;
                    
                    // Verificar colisiones
                    const floorX = Math.floor(newX);
                    const floorY = Math.floor(newY);
                    
                    if (floorX >= 0 && floorX < gameState.width && floorY >= 0 && floorY < gameState.height) {
                        const newIndex = floorY * gameState.width + floorX;
                        const tile = gameState.grid[newIndex];
                        
                        // Zombies Rambo no pueden pasar por obstáculos
                        if (![TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX, TILE_TYPES.WATER, 
                             TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START, TILE_TYPES.CACTUS].includes(tile)) {
                            
                            // Verificar si hay otro zombie en esa posición
                            const zombieAtPos = gameState.zombies.find(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                            const ramboAtPos = gameState.zombieRambos.find(z => z !== rambo && Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                            
                            if (!zombieAtPos && !ramboAtPos) {
                                rambo.x = newX;
                                rambo.y = newY;
                            }
                        }
                    }
                } else {
                    // Movimiento aleatorio si el jugador no está en rango
                    if (Math.random() > 0.7) {
                        const moveX = (Math.random() - 0.5) * 0.5;
                        const moveY = (Math.random() - 0.5) * 0.5;
                        
                        let newX = rambo.x + moveX;
                        let newY = rambo.y + moveY;
                        
                        // Verificar colisiones
                        const floorX = Math.floor(newX);
                        const floorY = Math.floor(newY);
                        
                        if (floorX >= 0 && floorX < gameState.width && floorY >= 0 && floorY < gameState.height) {
                            const newIndex = floorY * gameState.width + floorX;
                            const tile = gameState.grid[newIndex];
                            
                            if (![TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX, TILE_TYPES.WATER, 
                                 TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START, TILE_TYPES.CACTUS].includes(tile)) {
                                
                                const zombieAtPos = gameState.zombies.find(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                                const ramboAtPos = gameState.zombieRambos.find(z => z !== rambo && Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                                
                                if (!zombieAtPos && !ramboAtPos) {
                                    rambo.x = newX;
                                    rambo.y = newY;
                                }
                            }
                        }
                    }
                }

                // Verificar colisión con jugador
                if (Math.floor(rambo.x) === Math.floor(gameState.player.x) && Math.floor(rambo.y) === Math.floor(gameState.player.y)) {
                    handlePlayerHit();
                }
            });
        }

        function shootFromZombieRambo(rambo, dirX, dirY) {
            // Crear un proyectil que se mueve en línea recta
            const bullet = {
                x: rambo.x,
                y: rambo.y,
                vx: dirX * 0.5,
                vy: dirY * 0.5,
                damage: 10,
                life: 60,
                owner: 'rambo'
            };
            
            // Añadir a la lista de balas
            if (!gameState.bullets) gameState.bullets = [];
            gameState.bullets.push(bullet);
            
            // Iniciar animación del proyectil
            createProjectileAnimation(rambo.x, rambo.y, dirX, dirY, '#7c2d12');
        }

        function handlePlayerHit() {
            gameState.lives--;
            updateHUD();
            
            if (gameState.lives <= 0) {
                endGame(false, '¡Los zombies te han devorado!');
            } else {
                showMessage('¡Zombie!', 'Un zombie te ha atacado. -1 vida.', 1000);
                // Reposicionar jugador en el inicio
                gameState.player.x = gameState.startPosition.x;
                gameState.player.y = gameState.startPosition.y;
                gameState.waterSteps = 0;
                gameState.hasBox = false;
                const waterCounter = document.getElementById('water-counter');
                if (waterCounter) waterCounter.classList.remove('active');
            }
        }

        function movePlayer(dx, dy) {
            if (!gameState.playing || gameState.paused || gameState.levelCompleted) return;

            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;

            // Actualizar ángulo del jugador
            if (dx !== 0 || dy !== 0) {
                gameState.player.angle = Math.atan2(dy, dx);
            }

            // Verificar límites
            if (newX < 0 || newX >= gameState.width || newY < 0 || newY >= gameState.height) {
                return;
            }

            const newIndex = Math.floor(newY) * gameState.width + Math.floor(newX);
            const tile = gameState.grid[newIndex];

            // Verificar si es la salida inicial
            if (tile === TILE_TYPES.START && (dx !== 0 || dy !== 0)) {
                // Cambiar entrada a vacía
                gameState.grid[Math.floor(gameState.player.y) * gameState.width + Math.floor(gameState.player.x)] = TILE_TYPES.EMPTY;
                // Poner entrada normal en la nueva posición
                gameState.grid[newIndex] = TILE_TYPES.EMPTY;
            }

            // Manejar cactus - daña al jugador
            if (tile === TILE_TYPES.CACTUS) {
                gameState.lives--;
                updateHUD();
                showMessage('¡Cactus!', 'Te has pinchado con un cactus. -1 vida.', 1000);
                if (gameState.lives <= 0) {
                    endGame(false, '¡Muerto por cactus!');
                    return;
                }
            }

            // Verificar colisiones normales
            if ([TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX].includes(tile)) {
                // Si es una caja, intentar arrastrarla
                if (tile === TILE_TYPES.BOX) {
                    return tryDragBox(dx, dy, Math.floor(newX), Math.floor(newY), newIndex);
                }
                return;
            }

            // Manejar agua
            if (tile === TILE_TYPES.WATER) {
                return moveIntoWater(dx, dy, newX, newY);
            }

            // Manejar portal
            if (tile === TILE_TYPES.PORTAL) {
                return usePortal(newIndex);
            }

            // Recolectar items
            collectItem(newIndex, tile);

            // Mover jugador
            gameState.player.x = newX;
            gameState.player.y = newY;
            
            // Actualizar contador de agua
            if (tile !== TILE_TYPES.WATER && gameState.waterSteps > 0) {
                gameState.waterSteps = 0;
                const waterCounter = document.getElementById('water-counter');
                if (waterCounter) waterCounter.classList.remove('active');
            }

            renderGameGrid();
            updateHUD();
            checkZombieCollision();
        }

        function tryDragBox(dx, dy, boxX, boxY, boxIndex) {
            // Verificar si la caja puede ser arrastrada en esa dirección
            const targetX = boxX + dx;
            const targetY = boxY + dy;
            
            if (targetX < 0 || targetX >= gameState.width || targetY < 0 || targetY >= gameState.height) {
                return; // Fuera de límites
            }
            
            const targetIndex = targetY * gameState.width + targetX;
            const targetTile = gameState.grid[targetIndex];
            
            // Verificar si el destino está vacío
            if (targetTile === TILE_TYPES.EMPTY) {
                // Mover la caja
                gameState.grid[boxIndex] = TILE_TYPES.EMPTY;
                gameState.grid[targetIndex] = TILE_TYPES.BOX;
                
                showMessage('¡Caja arrastrada!', 'Has movido la caja.', 500);
            } else {
                showMessage('Bloqueado', 'La caja no puede moverse allí.', 500);
            }
            
            renderGameGrid();
            updateHUD();
        }

        function checkBoxGravity() {
            if (!gameState.playing || gameState.paused) return;
            
            // Verificar todas las cajas en el nivel
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.BOX) {
                    const x = i % gameState.width;
                    const y = Math.floor(i / gameState.width);
                    
                    // Verificar si hay algo debajo de la caja
                    if (y + 1 < gameState.height) {
                        const belowIndex = (y + 1) * gameState.width + x;
                        const belowTile = gameState.grid[belowIndex];
                        
                        // Si debajo está vacío o es agua, la caja cae
                        if (belowTile === TILE_TYPES.EMPTY || belowTile === TILE_TYPES.WATER) {
                            // Mover caja hacia abajo
                            gameState.grid[i] = TILE_TYPES.EMPTY;
                            gameState.grid[belowIndex] = TILE_TYPES.BOX;
                            
                            // Verificar si cae sobre el jugador
                            if (Math.floor(gameState.player.x) === x && Math.floor(gameState.player.y) === y + 1) {
                                gameState.lives--;
                                showMessage('¡Caja!', 'Una caja te ha caído encima. -1 vida.', 1000);
                                updateHUD();
                                if (gameState.lives <= 0) {
                                    endGame(false, '¡Aplastado por una caja!');
                                }
                            }
                            
                            // Verificar si cae sobre un zombie
                            const zombieIndex = gameState.zombies.findIndex(z => Math.floor(z.x) === x && Math.floor(z.y) === y + 1);
                            if (zombieIndex !== -1) {
                                gameState.zombies.splice(zombieIndex, 1);
                                gameState.stats.zombiesKilled++;
                                gameStats.totalZombies++;
                                saveStats();
                                showMessage('¡Zombie aplastado!', 'La caja ha aplastado a un zombie.', 1000);
                            }
                            
                            // Verificar si cae sobre un zombie Rambo
                            const ramboIndex = gameState.zombieRambos.findIndex(z => Math.floor(z.x) === x && Math.floor(z.y) === y + 1);
                            if (ramboIndex !== -1) {
                                gameState.zombieRambos.splice(ramboIndex, 1);
                                gameState.stats.zombiesKilled++;
                                gameStats.totalZombies++;
                                saveStats();
                                showMessage('¡Zombie Rambo aplastado!', 'La caja ha aplastado a un zombie Rambo.', 1000);
                            }
                            
                            renderGameGrid();
                        }
                    }
                }
            }
        }

        function moveIntoWater(dx, dy, newX, newY) {
            gameState.waterSteps++;
            const waterCounter = document.getElementById('water-counter');
            const waterStepsEl = document.getElementById('water-steps');
            
            if (waterCounter) waterCounter.classList.add('active');
            if (waterStepsEl) waterStepsEl.textContent = `${gameState.waterSteps}/5`;
            
            if (gameState.waterSteps > 5) {
                gameState.lives--;
                gameState.waterSteps = 0;
                showMessage('¡Ahogamiento!', 'Demasiado tiempo en el agua. -1 vida.', 1000);
                updateHUD();
                if (gameState.lives <= 0) {
                    endGame(false, '¡Te has ahogado!');
                }
                // Volver al inicio
                gameState.player.x = gameState.startPosition.x;
                gameState.player.y = gameState.startPosition.y;
                if (waterCounter) waterCounter.classList.remove('active');
            } else {
                gameState.player.x = newX;
                gameState.player.y = newY;
            }
            
            renderGameGrid();
            updateHUD();
            checkZombieCollision();
        }

        function usePortal(portalIndex) {
            // Encontrar otro portal
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.PORTAL && i !== portalIndex) {
                    const newX = i % gameState.width;
                    const newY = Math.floor(i / gameState.width);
                    
                    showMessage('¡Portal!', 'Teletransportado a otro portal.', 1000);
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    renderGameGrid();
                    updateHUD();
                    checkZombieCollision();
                    return;
                }
            }
        }

        function collectItem(index, tile) {
            switch(tile) {
                case TILE_TYPES.RIFLE:
                    gameState.ammo += 5;
                    gameState.inventory.rifles++;
                    gameState.weaponType = 'rifle';
                    gameState.shots = 10;
                    gameState.maxShots = 10;
                    if (selectedCharacter.rifleImage) {
                        gameState.player.image = selectedCharacter.rifleImage;
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Rifle encontrado!', '+5 munición, 10 tiros disponibles', 1000);
                    updateHUD();
                    break;
                    
                case TILE_TYPES.SHOTGUN:
                    gameState.ammo += 3;
                    gameState.inventory.shotguns++;
                    gameState.weaponType = 'shotgun';
                    gameState.shots = 10;
                    gameState.maxShots = 10;
                    if (selectedCharacter.shotgunImage) {
                        gameState.player.image = selectedCharacter.shotgunImage;
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Shotgun encontrada!', '+3 munición, 10 tiros disponibles', 1000);
                    updateHUD();
                    break;
                    
                case TILE_TYPES.KEY:
                    gameState.keys++;
                    gameState.inventory.keys++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Llave encontrada!', 'Ahora puedes abrir puertas', 1000);
                    
                    // Abrir puertas si hay llave
                    for (let i = 0; i < gameState.grid.length; i++) {
                        if (gameState.grid[i] === TILE_TYPES.DOOR) {
                            gameState.grid[i] = TILE_TYPES.EXIT;
                        }
                    }
                    updateHUD();
                    renderGameGrid();
                    break;
                    
                case TILE_TYPES.COIN:
                    gameState.coins++;
                    gameState.inventory.coins++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    gameStats.playerCoins++;
                    gameStats.highscoreCoins = Math.max(gameStats.highscoreCoins, gameState.coins);
                    saveStats();
                    updateCoinsDisplay();
                    updateHUD();
                    break;
                    
                case TILE_TYPES.BOMB:
                    gameState.bombs++;
                    gameState.inventory.bombs++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Bomba encontrada!', 'Puedes usarla desde el inventario', 1000);
                    updateHUD();
                    break;
                    
                case TILE_TYPES.SWORD:
                    gameState.inventory.swords++;
                    gameState.weaponType = 'sword';
                    gameState.shots = 999;
                    gameState.maxShots = 999;
                    if (selectedCharacter.swordImage) {
                        gameState.player.image = selectedCharacter.swordImage;
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Espada encontrada!', 'Daño aumentado, ataques ilimitados', 1000);
                    updateHUD();
                    break;
                    
                case TILE_TYPES.BULLET:
                    gameState.inventory.bullets++;
                    // Añadir balas al arma actual
                    if (gameState.weaponType === 'rifle' || gameState.weaponType === 'shotgun') {
                        gameState.shots = Math.min(gameState.maxShots, gameState.shots + 20);
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Balas encontradas!', '+20 balas para tu arma', 1000);
                    updateHUD();
                    break;
                    
                case TILE_TYPES.AMMO:
                    gameState.inventory.ammo++;
                    // Añadir munición al inventario
                    if (gameState.weaponType === 'rifle') {
                        gameState.ammo += 10;
                    } else if (gameState.weaponType === 'shotgun') {
                        gameState.ammo += 5;
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showMessage('¡Munición encontrada!', '+10 munición para tu arma', 1000);
                    updateHUD();
                    break;
            }
        }

        function checkZombieCollision() {
            const playerX = Math.floor(gameState.player.x);
            const playerY = Math.floor(gameState.player.y);
            
            const zombieCollision = gameState.zombies.some(z => 
                Math.floor(z.x) === playerX && Math.floor(z.y) === playerY
            );
            
            const ramboCollision = gameState.zombieRambos.some(z => 
                Math.floor(z.x) === playerX && Math.floor(z.y) === playerY
            );
            
            if (zombieCollision || ramboCollision) {
                handlePlayerHit();
            }
        }

        function attack() {
            if (!gameState.playing || gameState.paused) return;
            
            if (gameState.weaponType === null) {
                showMessage('Sin arma', 'Busca un arma para atacar', 1000);
                return;
            }

            if (gameState.weaponType === 'sword') {
                // Ataque con espada (ilimitado)
                swordAttack();
                return;
            }

            // Verificar si hay tiros disponibles
            if (gameState.shots <= 0) {
                showMessage('Sin tiros', 'Recarga buscando más balas', 1000);
                return;
            }

            gameState.shots--;
            
            if (gameState.weaponType === 'rifle') {
                rifleAttack();
            } else if (gameState.weaponType === 'shotgun') {
                shotgunAttack();
            }

            updateHUD();
            renderGameGrid();
        }

        function rifleAttack() {
            // Eliminar zombies y obstáculos en línea recta desde la posición del jugador
            rifleAttackFromPosition(gameState.player.x, gameState.player.y, gameState.player.angle);
        }

        function rifleAttackFromPosition(x, y, angle) {
            // Calcular dirección del disparo
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            
            // Disparar en línea recta
            let currentX = x;
            let currentY = y;
            let distance = 0;
            const maxDistance = 10;
            
            while (distance < maxDistance) {
                currentX += dirX;
                currentY += dirY;
                distance++;
                
                const floorX = Math.floor(currentX);
                const floorY = Math.floor(currentY);
                
                // Verificar límites
                if (floorX < 0 || floorX >= gameState.width || floorY < 0 || floorY >= gameState.height) {
                    break;
                }
                
                const index = floorY * gameState.width + floorX;
                const tile = gameState.grid[index];
                
                // Destruir obstáculos destruibles
                if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS].includes(tile)) {
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    break;
                }
                
                // No pasar por paredes o rocas
                if ([TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START].includes(tile)) {
                    break;
                }
                
                // Eliminar zombie normal si hay
                const zombieIndex = gameState.zombies.findIndex(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                if (zombieIndex !== -1) {
                    gameState.zombies.splice(zombieIndex, 1);
                    gameState.stats.zombiesKilled++;
                    gameStats.totalZombies++;
                    saveStats();
                    break;
                }
                
                // Eliminar zombie Rambo si hay
                const ramboIndex = gameState.zombieRambos.findIndex(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                if (ramboIndex !== -1) {
                    gameState.zombieRambos.splice(ramboIndex, 1);
                    gameState.stats.zombiesKilled++;
                    gameStats.totalZombies++;
                    saveStats();
                    break;
                }
            }
            
            // Animación de disparo
            createProjectileAnimation(x, y, dirX, dirY, '#fbbf24');
            showMessage('¡Disparo de rifle!', `Tiros restantes: ${gameState.shots}`, 1000);
        }

        function shotgunAttack() {
            // Eliminar en área cercana desde la posición del jugador
            shotgunAttackFromPosition(gameState.player.x, gameState.player.y, gameState.player.angle);
        }

        function shotgunAttackFromPosition(x, y, angle) {
            // Disparo de shotgun en cono
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            
            // Crear múltiples direcciones para el efecto de cono
            const angles = [-0.3, -0.15, 0, 0.15, 0.3];
            
            angles.forEach(angleOffset => {
                // Rotar dirección
                const cos = Math.cos(angleOffset);
                const sin = Math.sin(angleOffset);
                const rotatedX = dirX * cos - dirY * sin;
                const rotatedY = dirX * sin + dirY * cos;
                
                // Disparar distancia corta
                let currentX = x;
                let currentY = y;
                
                for (let i = 0; i < 3; i++) {
                    currentX += rotatedX;
                    currentY += rotatedY;
                    
                    const floorX = Math.floor(currentX);
                    const floorY = Math.floor(currentY);
                    
                    // Verificar límites
                    if (floorX < 0 || floorX >= gameState.width || floorY < 0 || floorY >= gameState.height) {
                        break;
                    }
                    
                    const index = floorY * gameState.width + floorX;
                    const tile = gameState.grid[index];
                    
                    // Destruir obstáculos destruibles
                    if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS].includes(tile)) {
                        gameState.grid[index] = TILE_TYPES.EMPTY;
                        break;
                    }
                    
                    // No pasar por paredes o rocas
                    if ([TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START].includes(tile)) {
                        break;
                    }
                    
                    // Eliminar zombie normal si hay
                    const zombieIndex = gameState.zombies.findIndex(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                    if (zombieIndex !== -1) {
                        gameState.zombies.splice(zombieIndex, 1);
                        gameState.stats.zombiesKilled++;
                        gameStats.totalZombies++;
                        saveStats();
                        break;
                    }
                    
                    // Eliminar zombie Rambo si hay
                    const ramboIndex = gameState.zombieRambos.findIndex(z => Math.floor(z.x) === floorX && Math.floor(z.y) === floorY);
                    if (ramboIndex !== -1) {
                        gameState.zombieRambos.splice(ramboIndex, 1);
                        gameState.stats.zombiesKilled++;
                        gameStats.totalZombies++;
                        saveStats();
                        break;
                    }
                }
            });
            
            // Animación de disparo
            createProjectileAnimation(x, y, dirX, dirY, '#ef4444');
            showMessage('¡Disparo de shotgun!', `Tiros restantes: ${gameState.shots}`, 1000);
        }

        function swordAttack() {
            // Ataque con espada desde la posición del jugador
            swordAttackFromPosition(gameState.player.x, gameState.player.y, gameState.player.angle);
        }

        function swordAttackFromPosition(x, y, angle) {
            // Ataque de espada en dirección específica
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            
            for (let i = 1; i <= 2; i++) {
                const attackX = Math.floor(x + dirX * i);
                const attackY = Math.floor(y + dirY * i);
                
                if (attackX >= 0 && attackX < gameState.width && attackY >= 0 && attackY < gameState.height) {
                    const index = attackY * gameState.width + attackX;
                    const tile = gameState.grid[index];
                    
                    // Destruir obstáculos destruibles
                    if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS].includes(tile)) {
                        gameState.grid[index] = TILE_TYPES.EMPTY;
                    }
                    
                    // Eliminar zombie normal si hay
                    const zombieIndex = gameState.zombies.findIndex(z => Math.floor(z.x) === attackX && Math.floor(z.y) === attackY);
                    if (zombieIndex !== -1) {
                        gameState.zombies.splice(zombieIndex, 1);
                        gameState.stats.zombiesKilled++;
                        gameStats.totalZombies++;
                        saveStats();
                    }
                    
                    // Eliminar zombie Rambo si hay
                    const ramboIndex = gameState.zombieRambos.findIndex(z => Math.floor(z.x) === attackX && Math.floor(z.y) === attackY);
                    if (ramboIndex !== -1) {
                        gameState.zombieRambos.splice(ramboIndex, 1);
                        gameState.stats.zombiesKilled++;
                        gameStats.totalZombies++;
                        saveStats();
                    }
                }
            }
            
            // Animación de espada
            createProjectileAnimation(x, y, dirX, dirY, '#3b82f6');
            showMessage('¡Ataque de espada!', 'Espada: ataques ilimitados', 1000);
        }

        function createProjectileAnimation(startX, startY, dirX, dirY, color) {
            const board = document.getElementById('game-board');
            if (!board) return;
            
            // Convertir coordenadas del juego a píxeles
            const cellSize = 40;
            const startPixelX = (startX % 1) * cellSize + Math.floor(startX) * cellSize;
            const startPixelY = (startY % 1) * cellSize + Math.floor(startY) * cellSize;
            
            // Calcular posición final (200px en la dirección indicada)
            const endPixelX = startPixelX + dirX * 200;
            const endPixelY = startPixelY + dirY * 200;
            
            // Crear elemento de proyectil
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.style.left = startPixelX + 'px';
            projectile.style.top = startPixelY + 'px';
            projectile.style.backgroundColor = color;
            projectile.style.boxShadow = `0 0 10px ${color}`;
            projectile.style.setProperty('--end-x', (endPixelX - startPixelX) + 'px');
            projectile.style.setProperty('--end-y', (endPixelY - startPixelY) + 'px');
            projectile.style.animation = 'projectile 0.5s forwards';
            
            document.body.appendChild(projectile);
            
            setTimeout(() => {
                if (projectile.parentNode) {
                    projectile.parentNode.removeChild(projectile);
                }
            }, 500);
        }

        function useBomb() {
            if (gameState.bombs <= 0) {
                showMessage('Sin bombas', 'Busca bombas para usar', 1000);
                return;
            }
            
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.add('active');
            }
        }

        function placeBomb() {
            if (gameState.bombs <= 0) return;
            
            gameState.bombs--;
            gameState.inventory.bombs--;
            
            const bomb = {
                x: Math.floor(gameState.player.x),
                y: Math.floor(gameState.player.y),
                timer: 10
            };
            
            gameState.activeBombs.push(bomb);
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.remove('active');
            }
            showMessage('¡Bomba colocada!', 'Explotará en 10 segundos', 1000);
            updateHUD();
            renderGameGrid();
        }

        function cancelBomb() {
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.remove('active');
            }
        }

        function checkBombs() {
            if (!gameState.playing || gameState.paused) return;
            
            for (let i = gameState.activeBombs.length - 1; i >= 0; i--) {
                const bomb = gameState.activeBombs[i];
                bomb.timer--;
                
                if (bomb.timer <= 0) {
                    // Explotar bomba
                    explodeBomb(bomb.x, bomb.y);
                    gameState.activeBombs.splice(i, 1);
                }
            }
            
            if (gameState.activeBombs.length > 0) {
                renderGameGrid();
            }
        }

        function explodeBomb(x, y) {
            // Eliminar en todas las direcciones
            const directions = [
                {dx: 0, dy: 0},
                {dx: 1, dy: 0},
                {dx: -1, dy: 0},
                {dx: 0, dy: 1},
                {dx: 0, dy: -1}
            ];
            
            directions.forEach(dir => {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                if (newX >= 0 && newX < gameState.width && newY >= 0 && newY < gameState.height) {
                    const index = newY * gameState.width + newX;
                    const tile = gameState.grid[index];
                    
                    // No destruir entrada o salida
                    if (tile !== TILE_TYPES.START && tile !== TILE_TYPES.EXIT && tile !== TILE_TYPES.DOOR) {
                        gameState.grid[index] = TILE_TYPES.EMPTY;
                    }
                    
                    // Eliminar zombies normales
                    gameState.zombies = gameState.zombies.filter(z => 
                        !(Math.floor(z.x) === newX && Math.floor(z.y) === newY)
                    );
                    
                    // Eliminar zombies Rambo
                    gameState.zombieRambos = gameState.zombieRambos.filter(z => 
                        !(Math.floor(z.x) === newX && Math.floor(z.y) === newY)
                    );
                    
                    // Verificar si el jugador fue afectado
                    if (Math.floor(gameState.player.x) === newX && Math.floor(gameState.player.y) === newY) {
                        gameState.lives--;
                        showMessage('¡Explosión!', 'Fuiste afectado por la bomba. -1 vida.', 1000);
                        updateHUD();
                        if (gameState.lives <= 0) {
                            endGame(false, '¡Muerto por explosión!');
                        }
                    }
                }
            });
            
            showMessage('¡BOOM!', 'La bomba ha explotado', 1000);
        }

        function toggleInventory() {
            const modal = document.getElementById('inventory-modal');
            if (!modal) return;
            
            modal.classList.toggle('active');
            
            if (modal.classList.contains('active')) {
                updateInventoryDisplay();
            }
        }

        function updateInventoryDisplay() {
            const container = document.getElementById('inventory-items');
            if (!container) return;
            
            container.innerHTML = '';
            
            const items = [
                { key: 'rifles', name: 'Rifles', count: gameState.inventory.rifles, icon: 'rifle.png' },
                { key: 'shotguns', name: 'Shotguns', count: gameState.inventory.shotguns, icon: 'shotgun.png' },
                { key: 'swords', name: 'Espadas', count: gameState.inventory.swords, icon: 'espada.png' },
                { key: 'keys', name: 'Llaves', count: gameState.inventory.keys, icon: 'llave.png' },
                { key: 'coins', name: 'Monedas', count: gameState.inventory.coins, icon: 'moneda.png' },
                { key: 'bombs', name: 'Bombas', count: gameState.inventory.bombs, icon: 'bomba.png' },
                { key: 'bullets', name: 'Balas', count: gameState.inventory.bullets, icon: 'balas.png' },
                { key: 'ammo', name: 'Munición', count: gameState.inventory.ammo, icon: 'municiones.png' }
            ];
            
            items.forEach(item => {
                if (item.count > 0) {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'inventory-item';
                    itemEl.innerHTML = `
                        <div class="item-icon" style="background-image: url('${item.icon}')"></div>
                        <div class="item-count">${item.count}</div>
                        <div class="item-name">${item.name}</div>
                    `;
                    
                    if (item.key === 'bombs') {
                        itemEl.style.cursor = 'pointer';
                        itemEl.onclick = () => useBomb();
                        itemEl.title = 'Haz clic para usar bomba';
                    } else if (item.key === 'rifles' || item.key === 'shotguns' || item.key === 'swords') {
                        itemEl.style.cursor = 'pointer';
                        itemEl.onclick = () => equipWeapon(item.key);
                        itemEl.title = 'Haz clic para equipar arma';
                    } else if (item.key === 'bullets') {
                        itemEl.style.cursor = 'pointer';
                        itemEl.onclick = () => useBullets();
                        itemEl.title = 'Haz clic para usar balas';
                    } else if (item.key === 'ammo') {
                        itemEl.style.cursor = 'pointer';
                        itemEl.onclick = () => useAmmo();
                        itemEl.title = 'Haz clic para usar munición';
                    }
                    
                    container.appendChild(itemEl);
                }
            });
            
            if (container.children.length === 0) {
                container.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #94a3b8;">Inventario vacío</p>';
            }
        }

        function equipWeapon(weaponType) {
            switch(weaponType) {
                case 'rifles':
                    if (gameState.inventory.rifles > 0) {
                        gameState.weaponType = 'rifle';
                        gameState.shots = 10;
                        gameState.maxShots = 10;
                        if (selectedCharacter.rifleImage) {
                            gameState.player.image = selectedCharacter.rifleImage;
                        }
                        showMessage('¡Rifle equipado!', '10 tiros disponibles', 1000);
                    }
                    break;
                case 'shotguns':
                    if (gameState.inventory.shotguns > 0) {
                        gameState.weaponType = 'shotgun';
                        gameState.shots = 10;
                        gameState.maxShots = 10;
                        if (selectedCharacter.shotgunImage) {
                            gameState.player.image = selectedCharacter.shotgunImage;
                        }
                        showMessage('¡Shotgun equipada!', '10 tiros disponibles', 1000);
                    }
                    break;
                case 'swords':
                    if (gameState.inventory.swords > 0) {
                        gameState.weaponType = 'sword';
                        gameState.shots = 999;
                        gameState.maxShots = 999;
                        if (selectedCharacter.swordImage) {
                            gameState.player.image = selectedCharacter.swordImage;
                        }
                        showMessage('¡Espada equipada!', 'Ataques ilimitados', 1000);
                    }
                    break;
            }
            updateHUD();
            toggleInventory();
        }

        function useBullets() {
            if (gameState.inventory.bullets > 0 && (gameState.weaponType === 'rifle' || gameState.weaponType === 'shotgun')) {
                gameState.inventory.bullets--;
                gameState.shots = Math.min(gameState.maxShots, gameState.shots + 20);
                showMessage('¡Balas usadas!', '+20 balas para tu arma', 1000);
                updateHUD();
                updateInventoryDisplay();
            }
        }

        function useAmmo() {
            if (gameState.inventory.ammo > 0) {
                gameState.inventory.ammo--;
                if (gameState.weaponType === 'rifle') {
                    gameState.ammo += 10;
                } else if (gameState.weaponType === 'shotgun') {
                    gameState.ammo += 5;
                }
                showMessage('¡Munición usada!', '+10 munición para tu arma', 1000);
                updateHUD();
                updateInventoryDisplay();
            }
        }

        async function endGame(won, message) {
            gameState.playing = false;
            clearInterval(gameState.timer);
            clearInterval(gameState.zombieTimer);
            clearInterval(gameState.ramboTimer);
            clearInterval(gameState.bombTimer);
            clearInterval(gameState.boxGravityTimer);
            
            if (gameState.animationFrame) {
                cancelAnimationFrame(gameState.animationFrame);
            }
            
            gameState.autoShoot = false;

            if (won) {
                gameStats.totalLevels++;
                gameState.stats.levelsCompleted++;
                // Ganar monedas por completar nivel
                const coinsEarned = 10 + (currentLevelIndex + 1) * 5;
                gameStats.playerCoins += coinsEarned;
                
                // Avanzar al siguiente nivel automáticamente
                currentLevelIndex++;
                
                // Guardar progreso
                const progress = {
                    currentLevel: currentLevelIndex + 1,
                    totalLevels: gameStats.totalLevels,
                    playerCoins: gameStats.playerCoins
                };
                localStorage.setItem('sandboxProgress', JSON.stringify(progress));
                
                saveStats();
                
                // Guardar highscore en Firebase
                const scoreData = {
                    won: true,
                    coins: gameState.coins,
                    zombiesKilled: gameState.stats.zombiesKilled,
                    lives: gameState.lives,
                    time: gameState.time
                };
                
                await saveHighscore(scoreData);
                
                // Recargar highscores
                loadGlobalHighscores();
            }

            showMessage(
                won ? '¡VICTORIA!' : '¡GAME OVER!',
                `${message}<br><br>Personaje: ${selectedCharacter.name}<br>Vidas restantes: ${gameState.lives}<br>Monedas recolectadas: ${gameState.coins}<br>Zombies eliminados: ${gameState.stats.zombiesKilled}<br>Monedas totales: ${gameStats.playerCoins}`,
                0
            );

            const messageButton = document.getElementById('message-button');
            if (messageButton) {
                messageButton.onclick = () => {
                    hideMessage();
                    if (won) {
                        // Verificar si hay más niveles
                        if (currentLevelIndex < savedLevels.length) {
                            // Cargar siguiente nivel
                            currentLevel = savedLevels[currentLevelIndex];
                            startGame();
                        } else {
                            // Todos los niveles completados
                            showMessage('¡Felicidades!', 'Has completado todos los niveles. ¡Eres un héroe!', 3000);
                            setTimeout(() => showScreen('main-menu'), 3000);
                        }
                    } else {
                        // Reiniciar nivel actual
                        startGame();
                    }
                };
            }
        }

        // ============================
        // SISTEMA DE MENSAJES
        // ============================
        function showMessage(title, text, autoHide = 3000) {
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const messageModal = document.getElementById('message-modal');
            
            if (!messageTitle || !messageText || !messageModal) return;
            
            messageTitle.textContent = title;
            messageText.innerHTML = text;
            messageModal.classList.add('active');

            if (autoHide > 0) {
                setTimeout(hideMessage, autoHide);
            }
        }

        function hideMessage() {
            const messageModal = document.getElementById('message-modal');
            const levelsModal = document.getElementById('levels-modal');
            
            if (messageModal) messageModal.classList.remove('active');
            if (levelsModal) levelsModal.classList.remove('active');
        }

        // ============================
        // CREACIÓN DE 10 NIVELES POR DEFECTO (IA)
        // ============================
        function createDefaultLevels() {
            // Limpiar niveles existentes
            savedLevels = [];
            
            // Nivel 1 - El Comienzo MEJORADO (10x10) - ENTRADA NO ATRAPADA
            const level1 = createEmptyGrid(10, 10);
            // Paredes alrededor con aperturas
            for (let i = 0; i < 10; i++) {
                level1[i] = TILE_TYPES.WALL; // Top
                level1[90 + i] = TILE_TYPES.WALL; // Bottom
                level1[i * 10] = TILE_TYPES.WALL; // Left
                level1[i * 10 + 9] = TILE_TYPES.WALL; // Right
            }
            
            // Crear aperturas para que la entrada no esté atrapada
            // Quitar paredes alrededor de la entrada
            level1[0] = TILE_TYPES.EMPTY; // Esquina superior izquierda
            level1[1] = TILE_TYPES.EMPTY;
            level1[10] = TILE_TYPES.EMPTY;
            level1[11] = TILE_TYPES.EMPTY;
            
            // Entrada en posición segura (centro superior)
            level1[4] = TILE_TYPES.START;
            
            // Salida en posición opuesta (centro inferior)
            level1[85] = TILE_TYPES.DOOR;
            
            // Quitar pared cerca de la entrada para crear camino
            level1[5] = TILE_TYPES.EMPTY;
            level1[6] = TILE_TYPES.EMPTY;
            level1[14] = TILE_TYPES.EMPTY;
            level1[15] = TILE_TYPES.EMPTY;
            
            // Obstáculos distribuidos, no bloqueando la entrada
            level1[22] = TILE_TYPES.ROCK;
            level1[33] = TILE_TYPES.WATER;
            level1[45] = TILE_TYPES.CACTUS;
            level1[56] = TILE_TYPES.ROCK;
            
            // Zombies lejos de la entrada
            level1[44] = TILE_TYPES.ZOMBIE;
            level1[55] = TILE_TYPES.ZOMBIE;
            level1[66] = TILE_TYPES.ZOMBIE;
            
            // Items estratégicamente colocados
            level1[25] = TILE_TYPES.RIFLE; // Arma temprana
            level1[35] = TILE_TYPES.KEY;   // Llave para salida
            level1[65] = TILE_TYPES.COIN;  // Moneda
            level1[75] = TILE_TYPES.COIN;  // Otra moneda
            
            // Cajas que pueden usarse estratégicamente
            level1[23] = TILE_TYPES.BOX;
            level1[34] = TILE_TYPES.BOX;
            level1[46] = TILE_TYPES.BOX;
            
            // Crear camino claro desde entrada a salida
            level1[24] = TILE_TYPES.EMPTY;
            level1[34] = TILE_TYPES.EMPTY;
            level1[44] = TILE_TYPES.EMPTY;
            level1[54] = TILE_TYPES.EMPTY;
            level1[64] = TILE_TYPES.EMPTY;
            level1[74] = TILE_TYPES.EMPTY;
            level1[84] = TILE_TYPES.EMPTY;
            
            savedLevels.push({
                name: 'Nivel 1 - El Comienzo',
                width: 10,
                height: 10,
                timeLimit: 120,
                levelNumber: 1,
                levelType: 'ai',
                grid: level1
            });

            // Nivel 2 - El Laberinto (12x12)
            const level2 = createEmptyGrid(12, 12);
            // Paredes laberinto
            for (let i = 0; i < 12; i++) {
                level2[i] = TILE_TYPES.WALL;
                level2[132 + i] = TILE_TYPES.WALL;
                level2[i * 12] = TILE_TYPES.WALL;
                level2[i * 12 + 11] = TILE_TYPES.WALL;
            }
            // Paredes internas
            for (let i = 2; i < 10; i++) {
                level2[i * 12 + 5] = TILE_TYPES.WALL;
            }
            for (let i = 3; i < 9; i++) {
                level2[3 * 12 + i] = TILE_TYPES.WALL;
                level2[8 * 12 + i] = TILE_TYPES.WALL;
            }
            // Entrada y salida
            level2[13] = TILE_TYPES.START;
            level2[130] = TILE_TYPES.EXIT;
            // Zombies
            level2[50] = TILE_TYPES.ZOMBIE;
            level2[75] = TILE_TYPES.ZOMBIE;
            level2[100] = TILE_TYPES.ZOMBIE;
            // Items
            level2[30] = TILE_TYPES.SHOTGUN;
            level2[80] = TILE_TYPES.KEY;
            level2[95] = TILE_TYPES.COIN;
            level2[105] = TILE_TYPES.BOMB;
            // Agua
            level2[40] = TILE_TYPES.WATER;
            level2[41] = TILE_TYPES.WATER;
            // Cajas
            level2[42] = TILE_TYPES.BOX;
            level2[43] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 2 - El Laberinto',
                width: 12,
                height: 12,
                timeLimit: 150,
                levelNumber: 2,
                levelType: 'ai',
                grid: level2
            });

            // Nivel 3 - Agua Mortal (10x10)
            const level3 = createEmptyGrid(10, 10);
            // Paredes
            for (let i = 0; i < 10; i++) {
                level3[i] = TILE_TYPES.WALL;
                level3[90 + i] = TILE_TYPES.WALL;
                level3[i * 10] = TILE_TYPES.WALL;
                level3[i * 10 + 9] = TILE_TYPES.WALL;
            }
            // Mucha agua
            for (let i = 3; i < 7; i++) {
                for (let j = 3; j < 7; j++) {
                    level3[i * 10 + j] = TILE_TYPES.WATER;
                }
            }
            // Islas
            level3[11] = TILE_TYPES.START;
            level3[22] = TILE_TYPES.ROCK;
            level3[33] = TILE_TYPES.ROCK;
            level3[88] = TILE_TYPES.EXIT;
            // Zombies en islas
            level3[44] = TILE_TYPES.ZOMBIE;
            level3[55] = TILE_TYPES.ZOMBIE;
            level3[66] = TILE_TYPES.ZOMBIE;
            // Items en islas
            level3[12] = TILE_TYPES.RIFLE;
            level3[21] = TILE_TYPES.KEY;
            level3[78] = TILE_TYPES.COIN;
            level3[87] = TILE_TYPES.BULLET;
            // Cajas
            level3[23] = TILE_TYPES.BOX;
            level3[32] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 3 - Agua Mortal',
                width: 10,
                height: 10,
                timeLimit: 180,
                levelNumber: 3,
                levelType: 'ai',
                grid: level3
            });

            // Nivel 4 - Cactus Peligrosos (12x12)
            const level4 = createEmptyGrid(12, 12);
            // Paredes
            for (let i = 0; i < 12; i++) {
                level4[i] = TILE_TYPES.WALL;
                level4[132 + i] = TILE_TYPES.WALL;
                level4[i * 12] = TILE_TYPES.WALL;
                level4[i * 12 + 11] = TILE_TYPES.WALL;
            }
            // Campo de cactus
            for (let i = 2; i < 10; i++) {
                for (let j = 2; j < 10; j++) {
                    if (Math.random() > 0.7 && !(i === 2 && j === 2) && !(i === 9 && j === 9)) {
                        level4[i * 12 + j] = TILE_TYPES.CACTUS;
                    }
                }
            }
            // Entrada y salida
            level4[26] = TILE_TYPES.START;
            level4[117] = TILE_TYPES.DOOR;
            // Zombies
            level4[50] = TILE_TYPES.ZOMBIE;
            level4[62] = TILE_TYPES.ZOMBIE;
            level4[74] = TILE_TYPES.ZOMBIE;
            level4[86] = TILE_TYPES.ZOMBIE;
            // Items
            level4[38] = TILE_TYPES.SWORD;
            level4[63] = TILE_TYPES.KEY;
            level4[99] = TILE_TYPES.COIN;
            level4[100] = TILE_TYPES.COIN;
            level4[101] = TILE_TYPES.AMMO;
            // Cajas
            level4[39] = TILE_TYPES.BOX;
            level4[51] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 4 - Cactus Peligrosos',
                width: 12,
                height: 12,
                timeLimit: 200,
                levelNumber: 4,
                levelType: 'ai',
                grid: level4
            });

            // Nivel 5 - El Portal (15x15)
            const level5 = createEmptyGrid(15, 15);
            // Paredes
            for (let i = 0; i < 15; i++) {
                level5[i] = TILE_TYPES.WALL;
                level5[210 + i] = TILE_TYPES.WALL;
                level5[i * 15] = TILE_TYPES.WALL;
                level5[i * 15 + 14] = TILE_TYPES.WALL;
            }
            // Entrada y salida
            level5[16] = TILE_TYPES.START;
            level5[208] = TILE_TYPES.EXIT;
            // Portales
            level5[50] = TILE_TYPES.PORTAL;
            level5[150] = TILE_TYPES.PORTAL;
            // Obstáculos
            for (let i = 3; i < 12; i++) {
                level5[3 * 15 + i] = TILE_TYPES.WALL;
                level5[11 * 15 + i] = TILE_TYPES.WALL;
            }
            // Zombies
            level5[80] = TILE_TYPES.ZOMBIE;
            level5[95] = TILE_TYPES.ZOMBIE;
            level5[110] = TILE_TYPES.ZOMBIE;
            level5[125] = TILE_TYPES.ZOMBIE;
            // Items
            level5[32] = TILE_TYPES.RIFLE;
            level5[48] = TILE_TYPES.KEY;
            level5[162] = TILE_TYPES.SHOTGUN;
            level5[178] = TILE_TYPES.BOMB;
            // Monedas
            level5[65] = TILE_TYPES.COIN;
            level5[66] = TILE_TYPES.COIN;
            level5[67] = TILE_TYPES.COIN;
            // Cajas
            level5[33] = TILE_TYPES.BOX;
            level5[47] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 5 - El Portal',
                width: 15,
                height: 15,
                timeLimit: 220,
                levelNumber: 5,
                levelType: 'ai',
                grid: level5
            });

            // Nivel 6 - El Cementerio (15x15)
            const level6 = createEmptyGrid(15, 15);
            // Paredes de cementerio
            for (let i = 0; i < 15; i++) {
                level6[i] = TILE_TYPES.WALL;
                level6[210 + i] = TILE_TYPES.WALL;
                level6[i * 15] = TILE_TYPES.WALL;
                level6[i * 15 + 14] = TILE_TYPES.WALL;
            }
            // Tumbas (rocas)
            for (let i = 2; i < 13; i += 3) {
                for (let j = 2; j < 13; j += 3) {
                    level6[i * 15 + j] = TILE_TYPES.ROCK;
                }
            }
            // Entrada y salida
            level6[31] = TILE_TYPES.START;
            level6[193] = TILE_TYPES.DOOR;
            // MUCHOS ZOMBIES
            const zombiePositions6 = [45, 60, 75, 90, 105, 120, 135, 150, 165, 180];
            zombiePositions6.forEach(pos => {
                level6[pos] = TILE_TYPES.ZOMBIE;
            });
            // Items
            level6[46] = TILE_TYPES.SWORD;
            level6[61] = TILE_TYPES.RIFLE;
            level6[76] = TILE_TYPES.SHOTGUN;
            level6[121] = TILE_TYPES.KEY;
            // Munición
            level6[91] = TILE_TYPES.BULLET;
            level6[106] = TILE_TYPES.AMMO;
            // Monedas
            level6[136] = TILE_TYPES.COIN;
            level6[151] = TILE_TYPES.COIN;
            level6[166] = TILE_TYPES.COIN;
            // Cajas
            level6[47] = TILE_TYPES.BOX;
            level6[62] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 6 - El Cementerio',
                width: 15,
                height: 15,
                timeLimit: 240,
                levelNumber: 6,
                levelType: 'ai',
                grid: level6
            });

            // Nivel 7 - La Fortaleza (20x15)
            const level7 = createEmptyGrid(20, 15);
            // Paredes de fortaleza
            for (let i = 0; i < 20; i++) {
                level7[i] = TILE_TYPES.WALL;
                level7[280 + i] = TILE_TYPES.WALL;
            }
            for (let i = 0; i < 15; i++) {
                level7[i * 20] = TILE_TYPES.WALL;
                level7[i * 20 + 19] = TILE_TYPES.WALL;
            }
            // Paredes internas
            for (let i = 5; i < 15; i++) {
                level7[5 * 20 + i] = TILE_TYPES.WALL;
                level7[10 * 20 + i] = TILE_TYPES.WALL;
            }
            // Entrada y salida
            level7[21] = TILE_TYPES.START;
            level7[278] = TILE_TYPES.EXIT;
            // Agua como foso
            for (let i = 2; i < 18; i++) {
                level7[2 * 20 + i] = TILE_TYPES.WATER;
                level7[12 * 20 + i] = TILE_TYPES.WATER;
            }
            // Zombies guardianes
            const zombiePositions7 = [85, 105, 125, 145, 165, 185, 205, 225];
            zombiePositions7.forEach(pos => {
                level7[pos] = TILE_TYPES.ZOMBIE;
            });
            // Items
            level7[41] = TILE_TYPES.RIFLE;
            level7[42] = TILE_TYPES.BULLET;
            level7[63] = TILE_TYPES.SHOTGUN;
            level7[64] = TILE_TYPES.AMMO;
            level7[177] = TILE_TYPES.SWORD;
            level7[197] = TILE_TYPES.KEY;
            level7[217] = TILE_TYPES.BOMB;
            // Monedas
            level7[86] = TILE_TYPES.COIN;
            level7[106] = TILE_TYPES.COIN;
            level7[126] = TILE_TYPES.COIN;
            level7[146] = TILE_TYPES.COIN;
            // Cajas
            level7[43] = TILE_TYPES.BOX;
            level7[44] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 7 - La Fortaleza',
                width: 20,
                height: 15,
                timeLimit: 250,
                levelNumber: 7,
                levelType: 'ai',
                grid: level7
            });

            // Nivel 8 - El Desafío Final (15x15) - Añadir Zombie Rambo
            const level8 = createEmptyGrid(15, 15);
            // Paredes
            for (let i = 0; i < 15; i++) {
                level8[i] = TILE_TYPES.WALL;
                level8[210 + i] = TILE_TYPES.WALL;
                level8[i * 15] = TILE_TYPES.WALL;
                level8[i * 15 + 14] = TILE_TYPES.WALL;
            }
            // Laberinto complejo
            const walls8 = [
                16, 17, 18, 19, 20,
                31, 46, 61, 76,
                91, 106, 121, 136,
                151, 166, 181, 196,
                30, 45, 60, 75, 90,
                105, 120, 135, 150, 165,
                180, 195, 194, 193, 192, 191
            ];
            walls8.forEach(pos => {
                level8[pos] = TILE_TYPES.WALL;
            });
            // Entrada y salida
            level8[32] = TILE_TYPES.START;
            level8[188] = TILE_TYPES.DOOR;
            // MUCHOS ZOMBIES
            const zombiePositions8 = [48, 63, 78, 93, 108, 123, 138, 153, 168, 183];
            zombiePositions8.forEach(pos => {
                level8[pos] = TILE_TYPES.ZOMBIE;
            });
            // Añadir Zombie Rambo
            level8[98] = TILE_TYPES.ZOMBIE_RAMBO;
            // Cactus peligrosos
            level8[49] = TILE_TYPES.CACTUS;
            level8[64] = TILE_TYPES.CACTUS;
            level8[79] = TILE_TYPES.CACTUS;
            // Agua
            level8[94] = TILE_TYPES.WATER;
            level8[109] = TILE_TYPES.WATER;
            // Items esenciales
            level8[33] = TILE_TYPES.SWORD;
            level8[34] = TILE_TYPES.BULLET;
            level8[35] = TILE_TYPES.AMMO;
            level8[163] = TILE_TYPES.KEY;
            level8[178] = TILE_TYPES.BOMB;
            // Monedas
            level8[113] = TILE_TYPES.COIN;
            level8[128] = TILE_TYPES.COIN;
            level8[143] = TILE_TYPES.COIN;
            level8[158] = TILE_TYPES.COIN;
            // Cajas
            level8[36] = TILE_TYPES.BOX;
            level8[37] = TILE_TYPES.BOX;
            
            savedLevels.push({
                name: 'Nivel 8 - El Desafío Final',
                width: 15,
                height: 15,
                timeLimit: 260,
                levelNumber: 8,
                levelType: 'ai',
                grid: level8
            });

            // Nivel 9 - La Arena (20x20) - Más Zombies Rambo
            const level9 = createEmptyGrid(20, 20);
            // Paredes de arena
            for (let i = 0; i < 20; i++) {
                level9[i] = TILE_TYPES.WALL;
                level9[380 + i] = TILE_TYPES.WALL;
                level9[i * 20] = TILE_TYPES.WALL;
                level9[i * 20 + 19] = TILE_TYPES.WALL;
            }
            // Entrada y salida
            level9[21] = TILE_TYPES.START;
            level9[398] = TILE_TYPES.EXIT;
            // Obstáculos esparcidos
            for (let i = 2; i < 18; i++) {
                for (let j = 2; j < 18; j++) {
                    if (Math.random() > 0.85) {
                        level9[i * 20 + j] = TILE_TYPES.ROCK;
                    }
                }
            }
            // MUCHÍSIMOS ZOMBIES
            let zombieCount9 = 0;
            for (let i = 2; i < 18; i++) {
                for (let j = 2; j < 18; j++) {
                    if (Math.random() > 0.9 && zombieCount9 < 20) {
                        level9[i * 20 + j] = TILE_TYPES.ZOMBIE;
                        zombieCount9++;
                    }
                }
            }
            // ZOMBIES RAMBO
            let ramboCount9 = 0;
            for (let i = 2; i < 18; i++) {
                for (let j = 2; j < 18; j++) {
                    if (Math.random() > 0.95 && ramboCount9 < 5) {
                        level9[i * 20 + j] = TILE_TYPES.ZOMBIE_RAMBO;
                        ramboCount9++;
                    }
                }
            }
            // Items de supervivencia
            level9[22] = TILE_TYPES.SWORD;
            level9[23] = TILE_TYPES.RIFLE;
            level9[24] = TILE_TYPES.SHOTGUN;
            level9[42] = TILE_TYPES.BULLET;
            level9[43] = TILE_TYPES.AMMO;
            level9[44] = TILE_TYPES.BOMB;
            // Llave escondida
            level9[200] = TILE_TYPES.KEY;
            // Monedas
            for (let i = 0; i < 15; i++) {
                const pos = Math.floor(Math.random() * 400);
                if (level9[pos] === TILE_TYPES.EMPTY) {
                    level9[pos] = TILE_TYPES.COIN;
                }
            }
            // Cajas
            for (let i = 0; i < 10; i++) {
                const pos = Math.floor(Math.random() * 400);
                if (level9[pos] === TILE_TYPES.EMPTY) {
                    level9[pos] = TILE_TYPES.BOX;
                }
            }
            
            savedLevels.push({
                name: 'Nivel 9 - La Arena',
                width: 20,
                height: 20,
                timeLimit: 300,
                levelNumber: 9,
                levelType: 'ai',
                grid: level9
            });

            // Nivel 10 - El Infierno Zombie (25x20) - Muchos Zombies Rambo
            const level10 = createEmptyGrid(25, 20);
            // Paredes
            for (let i = 0; i < 25; i++) {
                level10[i] = TILE_TYPES.WALL;
                level10[475 + i] = TILE_TYPES.WALL;
            }
            for (let i = 0; i < 20; i++) {
                level10[i * 25] = TILE_TYPES.WALL;
                level10[i * 25 + 24] = TILE_TYPES.WALL;
            }
            // Entrada y salida
            level10[26] = TILE_TYPES.START;
            level10[498] = TILE_TYPES.DOOR;
            // MUCHOS ZOMBIES (más de 50)
            let zombieCount10 = 0;
            for (let i = 1; i < 19; i++) {
                for (let j = 1; j < 24; j++) {
                    if (Math.random() > 0.7 && zombieCount10 < 40) {
                        level10[i * 25 + j] = TILE_TYPES.ZOMBIE;
                        zombieCount10++;
                    }
                }
            }
            // MUCHOS ZOMBIES RAMBO
            let ramboCount10 = 0;
            for (let i = 1; i < 19; i++) {
                for (let j = 1; j < 24; j++) {
                    if (Math.random() > 0.85 && ramboCount10 < 20) {
                        level10[i * 25 + j] = TILE_TYPES.ZOMBIE_RAMBO;
                        ramboCount10++;
                    }
                }
            }
            // Obstáculos mortales
            for (let i = 3; i < 17; i++) {
                for (let j = 3; j < 22; j++) {
                    if (Math.random() > 0.8 && level10[i * 25 + j] === TILE_TYPES.EMPTY) {
                        level10[i * 25 + j] = TILE_TYPES.CACTUS;
                    }
                }
            }
            // Agua peligrosa
            for (let i = 5; i < 15; i++) {
                for (let j = 5; j < 20; j++) {
                    if (Math.random() > 0.85 && level10[i * 25 + j] === TILE_TYPES.EMPTY) {
                        level10[i * 25 + j] = TILE_TYPES.WATER;
                    }
                }
            }
            // Items de supervivencia (pocos)
            level10[27] = TILE_TYPES.SWORD;
            level10[28] = TILE_TYPES.RIFLE;
            level10[29] = TILE_TYPES.SHOTGUN;
            level10[51] = TILE_TYPES.BULLET;
            level10[52] = TILE_TYPES.AMMO;
            level10[53] = TILE_TYPES.BOMB;
            // Llave bien escondida
            level10[300] = TILE_TYPES.KEY;
            // Algunas monedas
            for (let i = 0; i < 10; i++) {
                const pos = Math.floor(Math.random() * 500);
                if (level10[pos] === TILE_TYPES.EMPTY) {
                    level10[pos] = TILE_TYPES.COIN;
                }
            }
            // Cajas
            for (let i = 0; i < 15; i++) {
                const pos = Math.floor(Math.random() * 500);
                if (level10[pos] === TILE_TYPES.EMPTY) {
                    level10[pos] = TILE_TYPES.BOX;
                }
            }
            
            savedLevels.push({
                name: 'Nivel 10 - El Infierno Zombie',
                width: 25,
                height: 20,
                timeLimit: 350,
                levelNumber: 10,
                levelType: 'ai',
                grid: level10
            });

            // Guardar todos los niveles
            localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
        }

        function createEmptyGrid(width, height) {
            return Array(width * height).fill(TILE_TYPES.EMPTY);
        }

        // ============================
        // SISTEMA DE CLICS EN EL TÍTULO (MODO CEREBRO OCULTO)
        // ============================
        function countTitleClicks() {
            titleClickCount++;
            
            if (titleClickCount >= 7 && !hiddenMenuVisible) {
                hiddenMenuVisible = true;
                const hiddenMenu = document.getElementById('hidden-menu-options');
                if (hiddenMenu) {
                    hiddenMenu.classList.remove('hidden');
                }
                // Sin mensaje para no dar pistas
            }
        }
    </script>
</body>
</html>
